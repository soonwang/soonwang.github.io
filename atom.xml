<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有个小站</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="http://soonwang.cn/atom.xml" rel="self"/>
  
  <link href="http://soonwang.cn/"/>
  <updated>2021-07-20T02:43:14.064Z</updated>
  <id>http://soonwang.cn/</id>
  
  <author>
    <name>王小木工</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BFC</title>
    <link href="http://soonwang.cn/2019/09/02/css-bfc/"/>
    <id>http://soonwang.cn/2019/09/02/css-bfc/</id>
    <published>2019-09-02T09:59:00.000Z</published>
    <updated>2021-07-20T02:43:14.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFC-概念"><a href="#BFC-概念" class="headerlink" title="BFC 概念"></a>BFC 概念</h2><p>BFC 即 Block Formatting Contexts（块级格式化上下文），属于普通流定位。具有BFC特性的元素可以看做是隔离了的独立容器，容器里面的元素不会再布局上影响到外面的元素。</p><span id="more"></span><h2 id="BFC-触发条件"><a href="#BFC-触发条件" class="headerlink" title="BFC 触发条件"></a>BFC 触发条件</h2><ul><li>body 根元素</li><li>浮动元素：float 值非 none</li><li>绝对定位元素：position absolute、fixed</li><li>display： inline-block、table-cell、table-caption</li><li>overflow 值 非 visible（hidden、auto、scroll）</li></ul><h2 id="BFC-特性-及-应用"><a href="#BFC-特性-及-应用" class="headerlink" title="BFC 特性 及 应用"></a>BFC 特性 及 应用</h2><ol><li>在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。不同 BFC 不会 发生 margin 折叠</li><li>在 BFC 中，每一个盒子的左外边缘（margin-left）会接触到 容器的 左边缘（border-left)</li><li>可以阻止元素 被 浮动元素 覆盖</li><li>清除元素内部浮动</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;BFC-概念&quot;&gt;&lt;a href=&quot;#BFC-概念&quot; class=&quot;headerlink&quot; title=&quot;BFC 概念&quot;&gt;&lt;/a&gt;BFC 概念&lt;/h2&gt;&lt;p&gt;BFC 即 Block Formatting Contexts（块级格式化上下文），属于普通流定位。具有BFC特性的元素可以看做是隔离了的独立容器，容器里面的元素不会再布局上影响到外面的元素。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CSS" scheme="http://soonwang.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS 包含块</title>
    <link href="http://soonwang.cn/2019/08/30/css-containing-block/"/>
    <id>http://soonwang.cn/2019/08/30/css-containing-block/</id>
    <published>2019-08-30T10:17:00.000Z</published>
    <updated>2021-07-20T02:43:14.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="确定包含块"><a href="#确定包含块" class="headerlink" title="确定包含块"></a>确定包含块</h2><ol><li>position 为 static 或 relative，包含块 就是它最近的祖先<strong>块</strong>元素（比如：inline-block, block 或 list-item）或格式化上下文（BFC）的内容区</li><li>position 为 absolute，包含块就是它最近的position 不是 static的祖先元素的内容区 + padding区</li><li>position fixed，包含块是viewport</li></ol><span id="more"></span><blockquote><p>如果 position 是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内容区+padding区</p></blockquote><ol><li>transform | perspective | filter 值不为none</li><li>will-change: transform | perspective | filter(filter只在Firefox上生效)</li><li>contain: paint (目前仅有chrome新版本支持)</li></ol><h2 id="根据包含块-计算-百分值"><a href="#根据包含块-计算-百分值" class="headerlink" title="根据包含块 计算 百分值"></a>根据包含块 计算 百分值</h2><ol><li>要计算height、top、bottom 的百分值，是相对于包含块的height值。</li><li>计算 width、left、right、padding、margin 这些属性由包含块的widt属性值来计算。</li></ol><h2 id="位置影响-left-right-top-bottom"><a href="#位置影响-left-right-top-bottom" class="headerlink" title="位置影响(left, right, top, bottom)"></a>位置影响(left, right, top, bottom)</h2><ol><li>position relative 元素：针对 元素本身的移动，本身元素所占的盒模型位置不变，即不会影响 周围元素的位置</li><li>position absolute 元素：针对其包含块的相对位置。比如：left: 0，则 该元素距离 包含块的左侧为0px</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;确定包含块&quot;&gt;&lt;a href=&quot;#确定包含块&quot; class=&quot;headerlink&quot; title=&quot;确定包含块&quot;&gt;&lt;/a&gt;确定包含块&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;position 为 static 或 relative，包含块 就是它最近的祖先&lt;strong&gt;块&lt;/strong&gt;元素（比如：inline-block, block 或 list-item）或格式化上下文（BFC）的内容区&lt;/li&gt;
&lt;li&gt;position 为 absolute，包含块就是它最近的position 不是 static的祖先元素的内容区 + padding区&lt;/li&gt;
&lt;li&gt;position fixed，包含块是viewport&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="CSS" scheme="http://soonwang.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Varnish 入门</title>
    <link href="http://soonwang.cn/2019/03/13/varnish-learn/"/>
    <id>http://soonwang.cn/2019/03/13/varnish-learn/</id>
    <published>2019-03-13T00:00:00.000Z</published>
    <updated>2021-07-20T02:43:14.064Z</updated>
    
    <content type="html"><![CDATA[<p>Varnish是一款高性能、开源的反向代理服务器，支持负载均衡，经常被用作缓存服务，能够极大的提高网站的响应速度。</p><p>Varnish 进程分为master进程和worker进程，master进程负责读取配置文件、创建和管理子进程等，worker进程则负责处理请求。一旦子进程挂了，master进程会立即重新启动子进程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>mac 上安装可以使用Homebrew</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install varnish</span><br></pre></td></tr></table></figure><span id="more"></span><p>启动命令（后台运行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew services start varnish</span><br></pre></td></tr></table></figure><p>默认端口是8080，可以在plist中修改端口</p><p><code>~/Library/LaunchAgents/homebrew.mxcl.varnish.plist</code></p><ul><li>n：运行目录路径</li><li>f: 配置文件路径</li><li>a: 启动端口</li><li>s：缓存方式</li></ul><p>varnish的默认配置文件位置位于<code>/usr/local/etc/varnish/default.vcl</code></p><p>通过homebrew安装的varnish，在调试配置文件时使用varnishlog会提示<code>VSM: Could not get hold of varnishd, is it running?</code></p><h2 id="Varnish-配置语言-VCL"><a href="#Varnish-配置语言-VCL" class="headerlink" title="Varnish 配置语言 VCL"></a>Varnish 配置语言 VCL</h2><h3 id="运算符-Operator"><a href="#运算符-Operator" class="headerlink" title="运算符 Operator"></a>运算符 Operator</h3><ul><li>= 赋值</li><li>== 比较</li><li>~ 匹配，可以使用正则表达式，或者ACLs</li><li>! 否定</li><li>&amp;&amp; 逻辑与</li><li>|| 逻辑或</li></ul><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul><li>if、else、elseif（elsif | elif | else if 四个都一样）</li><li><strong>没有循环语句</strong></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>五种数据类型：String， boolean，time，duration，integer</li><li>使用<code>set</code> 和 <code>unset</code> 设置或者移除</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set req.http.User-Agent = &quot;unknown&quot;;</span><br><span class="line">unset req.http.Range;</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>基本的字符串形式使用双引号 “…”，不允许跨行</li><li>反斜杆不是特殊符号，所以不需要对反斜杠进行转义</li><li>比较长的字符串可以使用{“…”}，可以包含双引号、换行符等，不包含NUL（0x00）</li></ul><h4 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h4><ul><li>now 函数返回当前时间</li><li>在字符串上下文，返回格式化的字符串</li></ul><h4 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h4><p>number + 时间单位，比如： 1.5w</p><ul><li>ms: milliseconds</li><li>s: seconds</li><li>m: minutes</li><li>h: hours</li><li>d: days</li><li>w: weeks</li><li>y: years</li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>Varnish 使用 Perl-compatible regular expressions（pcre）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (req.http.host !~ &quot;(?i)example\.com$&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="include-引入VCL文件"><a href="#include-引入VCL文件" class="headerlink" title="include 引入VCL文件"></a>include 引入VCL文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &quot;foo.vcl&quot;;</span><br></pre></td></tr></table></figure><h3 id="import-加载-Varnish模块（VMODS）"><a href="#import-加载-Varnish模块（VMODS）" class="headerlink" title="import 加载 Varnish模块（VMODS）"></a>import 加载 Varnish模块（VMODS）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import std;</span><br><span class="line">sub vcl_recv &#123;</span><br><span class="line">    std.log(&quot;foo&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>单行注释： <code>#</code>、 <code>||</code> </li><li>多行注释： <code>/* block */</code></li></ul><h3 id="定义-backend"><a href="#定义-backend" class="headerlink" title="定义 backend"></a>定义 backend</h3><p>varnish中的backend 和 nginx里 upstream 中 server概念很像，一个backend对象指定服务的host和端口，包括类似于健康检查的机制</p><p>定义一个 backend 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">backend name &#123;</span><br><span class="line">    .attribute = &quot;value&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用属性有 host（必填）、port、probe（类似于健康检查机制，后面会写到）</p><h3 id="定义-Probes"><a href="#定义-Probes" class="headerlink" title="定义 Probes"></a>定义 Probes</h3><p>probe 用于 请求 backend 状态，backend返回的状态不符合预期，则会标记该backend下线</p><p>定义一个name为 healthcheck的 probe</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">probe healthcheck &#123;</span><br><span class="line">    .url = &quot;/health/check&quot;;</span><br><span class="line">    .timeout = 2s;</span><br><span class="line">    .interval = 5s;</span><br><span class="line">    .expected_response = 200; # 服务正常返回的http状态码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合 backend使用，定义一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend default &#123;</span><br><span class="line">    .host: &quot;127.0.0.1&quot;;</span><br><span class="line">    .port: 8080;</span><br><span class="line">    .probe: healthcheck;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="director-多个后端集合，负载均衡"><a href="#director-多个后端集合，负载均衡" class="headerlink" title="director 多个后端集合，负载均衡"></a>director 多个后端集合，负载均衡</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">director fed round-robin &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .backend = fed1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        .backend = fed2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acl-权限控制列表（Access-control-lists）"><a href="#acl-权限控制列表（Access-control-lists）" class="headerlink" title="acl 权限控制列表（Access control lists）"></a>acl 权限控制列表（Access control lists）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">acl local &#123;</span><br><span class="line">    &quot;localhost&quot;;</span><br><span class="line">    &quot;127.0.0.1&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配ip地址的时候，使用匹配运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (client.ip ~ local) &#123;</span><br><span class="line">    return (pipe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子程序-Subroutines"><a href="#子程序-Subroutines" class="headerlink" title="子程序 Subroutines"></a>子程序 Subroutines</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub pip_if_local &#123;</span><br><span class="line">    if (client.ip ~ local) &#123;</span><br><span class="line">        return (pipe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子程序中不能引入参数，也没有返回值</li><li>varnish 内置子程序 命名为vcl.*，自定义子程序不能以<code>vcl</code>开头</li><li>调用子程序，使用关键字 <code>call</code> 后面跟上子程序名字<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call pip_if_local;</span><br></pre></td></tr></table></figure></li></ul><h2 id="几个常用的内置子程序"><a href="#几个常用的内置子程序" class="headerlink" title="几个常用的内置子程序"></a>几个常用的内置子程序</h2><h3 id="vcl-recv"><a href="#vcl-recv" class="headerlink" title="vcl_recv"></a>vcl_recv</h3><p>用于接收和处理请求。</p><p>举个栗子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sub vcl_recv &#123;</span><br><span class="line">    if (req.url ~ &quot;/public/&quot;) &#123;</span><br><span class="line">        return (hash);</span><br><span class="line">    &#125;</span><br><span class="line">    return (pass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将请求中匹配<code>/public/</code>的请求，进入hash阶段，请求转到<code>vcl_hash</code>，其余请求进入pass模式，处理转到<code>vcl_pass</code></p><p>return 支持5个参数：</p><ul><li>hash：进入<code>vcl_hash</code></li><li>pass: 进入<code>vcl_pass</code></li><li>pipe: 进入<code>vcl_pip</code></li><li>synth(status code, reason)： 进入<code>vcl_synth</code></li><li>purge：清除缓存</li></ul><h3 id="vcl-backend-fetch"><a href="#vcl-backend-fetch" class="headerlink" title="vcl_backend_fetch"></a>vcl_backend_fetch</h3><p>在向后端发请求前执行，这个阶段可以修改请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub vcl_backedn_fetch &#123;</span><br><span class="line">    unset bereq.http.Cookie;</span><br><span class="line">    return (fetch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return 支持两个参数</p><ul><li>fetch：发送请求到后端</li><li>abandon： 放弃请求后端。</li></ul><h3 id="vcl-backend-response"><a href="#vcl-backend-response" class="headerlink" title="vcl_backend_response"></a>vcl_backend_response</h3><p>当从后端获取到请求响应头后执行，可以在这个阶段处理删除或添加响应头的事情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub vcl_backend_response &#123;</span><br><span class="line">    set beresp.ttl = 5m;</span><br><span class="line">    unset beresp.http.Set-Cookie;</span><br><span class="line">    return (deliver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子设置资源的缓存时间、删除请求响应头里的Set-Cookie。<br>return 支持三个参数</p><ul><li>deliver： 返回数据给用户端</li><li>abandon：放弃后端请求，resp.status 为 503，进入<code>vcl_synth</code></li><li>retry：重试后端事务，达到最大次数限制后进入<code>vcl_backend_error</code></li></ul><h3 id="vcl-deliver"><a href="#vcl-deliver" class="headerlink" title="vcl_deliver"></a>vcl_deliver</h3><p>当从后端获取到所有信息后，在返回用户前执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub vcl_deliver &#123;</span><br><span class="line">    if (obj.hits &gt; 0) &#123;</span><br><span class="line">        set resp.http.X-Varnish-Cache = &quot;HIT&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        set resp.http.X-Varnish-Cache = &quot;MISS&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return (deliver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中判断是否是命中缓存，并在响应头中显示。<br>return支持 三个参数：</p><ul><li>deliver 返回数据给用户端</li><li>restart 重新启动事务。增加了重新启动计数器。如果重启的次数超过了max_restarts的设置，就会抛出一个错误</li><li>synth(status code, reason) 带着synth的参数resp.status和resp.reason转到vcl_synth处理。</li></ul><h3 id="vcl-init"><a href="#vcl-init" class="headerlink" title="vcl_init"></a>vcl_init</h3><p>在VCL加载完成，请求进入之前执行，一般用来初始化VMODs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import directors;    # load the directors</span><br><span class="line"></span><br><span class="line">backend server1 &#123;</span><br><span class="line">    .host = &quot;127.0.0.1&quot;;</span><br><span class="line">&#125;</span><br><span class="line">backend server2 &#123;</span><br><span class="line">    .host = &quot;xxxxxxxxx&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub vcl_init &#123;</span><br><span class="line">    new bar = directors.round_robin();</span><br><span class="line">    bar.add_backend(server1);</span><br><span class="line">    bar.add_backend(server2);</span><br><span class="line">    return (ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub vcl_recv &#123;</span><br><span class="line">    </span><br><span class="line">    set req.backend_hint = bar.backend();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return 支持两个参数</p><ul><li>ok 正常返回，继续</li><li>fail 终止加载VCL</li></ul><h3 id="vcl-fini"><a href="#vcl-fini" class="headerlink" title="vcl_fini"></a>vcl_fini</h3><p>在所有请求都处理完，VCL被丢弃后执行，一般用来清理VMODS。return (ok)。</p><p>更多详细的内置子程序可以参考:</p><ul><li><a href="https://jefferywang.gitbooks.io/varnish_4_1_doc_zh/content/chapter4_2.html">https://jefferywang.gitbooks.io/varnish_4_1_doc_zh/content/chapter4_2.html</a></li><li><a href="https://varnish-cache.org/docs/4.1/users-guide/vcl-built-in-subs.html#vcl-built-in-subs">https://varnish-cache.org/docs/4.1/users-guide/vcl-built-in-subs.html#vcl-built-in-subs</a></li></ul><p>varnish的内置子程序 调用状态可以看官网的两张张图：</p><ul><li>Client端：</li></ul><p><img data-src="https://kaola-haitao.oss.kaolacdn.com/dfe8e572-93e7-4474-a8d5-a97fab3b113b_1011_1387.svg" alt="image"></p><ul><li>Backend端：</li></ul><p><img data-src="https://kaola-haitao.oss.kaolacdn.com/9ef88c3c-bdb2-455c-afc0-df24e71e53c6_976_913.svg" alt="image"></p><h2 id="请求中的几个对象"><a href="#请求中的几个对象" class="headerlink" title="请求中的几个对象"></a>请求中的几个对象</h2><ul><li>req： 请求对象，在客户端阶段都存在</li><li>bereq：backend的请求，varnish在发送到backend之前构造的bereq，基于req创建</li><li>beresp：backend的响应对象</li><li>resp：返回给用户之前的响应，可以在vcl_deliver中修改</li><li>obj：大部分只在<code>vcl_hit</code>中，obj.hits 标识是否命中缓存，也存在于<code>vcl_deliver</code></li></ul><h2 id="调试配置文件"><a href="#调试配置文件" class="headerlink" title="调试配置文件"></a>调试配置文件</h2><p>使用std模块 和 varnishlog 可以 看到varnish 处理请求的各个状态的日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vcl 4.0;</span><br><span class="line">import std;</span><br><span class="line"></span><br><span class="line">sub vcl_recv &#123;</span><br><span class="line">    std.log(&quot;vcl_recv req.url: &quot; + req.url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在命令行中使用 <code>varnishlog -g raw</code>即可看到varnish处理请求的各个状态。<br>需要注意的是，<code>varnishlog</code>命令可能没有注册到全局，需要自行定位到bin文件下执行。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://varnish-cache.org/docs/4.1/reference/vcl.html#vcl-7">https://varnish-cache.org/docs/4.1/reference/vcl.html#vcl-7</a></li><li><a href="https://varnish-cache.org/docs/4.1/users-guide/vcl-built-in-subs.html">https://varnish-cache.org/docs/4.1/users-guide/vcl-built-in-subs.html</a></li><li><a href="https://jefferywang.gitbooks.io/varnish_4_1_doc_zh/content/chapter1.html">https://jefferywang.gitbooks.io/varnish_4_1_doc_zh/content/chapter1.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-varnish-intro/index.html">https://www.ibm.com/developerworks/cn/opensource/os-cn-varnish-intro/index.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Varnish是一款高性能、开源的反向代理服务器，支持负载均衡，经常被用作缓存服务，能够极大的提高网站的响应速度。&lt;/p&gt;
&lt;p&gt;Varnish 进程分为master进程和worker进程，master进程负责读取配置文件、创建和管理子进程等，worker进程则负责处理请求。一旦子进程挂了，master进程会立即重新启动子进程。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;mac 上安装可以使用Homebrew&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew install varnish&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="varnish" scheme="http://soonwang.cn/tags/varnish/"/>
    
    <category term="缓存服务器" scheme="http://soonwang.cn/tags/%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>eggjs启动从回车到ready</title>
    <link href="http://soonwang.cn/2018/10/27/eggjs-from-enter-to-ready/"/>
    <id>http://soonwang.cn/2018/10/27/eggjs-from-enter-to-ready/</id>
    <published>2018-10-27T09:35:20.000Z</published>
    <updated>2021-07-20T02:43:14.064Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript代码是单线程运行的，因而一旦有未捕获的异常抛出线程就会挂掉，业务也就不可访问了，所以一般我们在使用koa，express，thinkjs等其他node框架时一般会使用pm2去管理node进程，保证业务的高可用性。而阿里开源的egg框架本身自带的egg-cluster模板已经帮我们做了这个事情，egg的多进程模型和进程间通信官方文档上写的已经很清楚了，今天学习一下源码，希望有所收获。</p><h2 id="egg-bin-dev"><a href="#egg-bin-dev" class="headerlink" title="egg-bin dev"></a>egg-bin dev</h2><p>运行一个egg项目，<code>npm run dev</code>在package.json文件里我们发现默认其实执行的是<code>egg-bin dev</code>。egg-bin原来是egg提供的一个开发时使用的命令行工具，翻开egg-bin的代码，我们可以看到egg-bin其实是基于<a href="http://npm.taobao.org/package/common-bin">common-bin</a>开发的，这里不赘述common-bin的用法，感兴趣的童鞋自行去查阅。在<code>lib/cmd/dev.js</code>里我们可以看到<code>egg-bin dev</code>执行的逻辑（去掉debug日志）：</p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* <span class="function"><span class="title">run</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> devArgs = <span class="keyword">yield</span> <span class="built_in">this</span>.formatArgs(context);</span><br><span class="line">    <span class="keyword">const</span> env = &#123;</span><br><span class="line">      <span class="attr">NODE_ENV</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">      <span class="attr">EGG_MASTER_CLOSE_TIMEOUT</span>: <span class="number">1000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">      <span class="attr">execArgv</span>: context.execArgv,</span><br><span class="line">      <span class="attr">env</span>: <span class="built_in">Object</span>.assign(env, context.env),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">this</span>.helper.forkNode(<span class="built_in">this</span>.serverBin, devArgs, options);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出主要有两步，</p><ol><li>this.formatArgs(context)，将context上的参数转成自己需要的格式</li><li>this.helper.forkNode()，这个是<code>common-bin</code>的语法：</li></ol><blockquote><p>forkNode(modulePath, args, opt) - fork child process, wrap with promise and gracefull exit</p></blockquote><p>forkNode函数用于fork一个子进程，第一个参数子进程要执行的文件的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.serverBin = path.join(__dirname, <span class="string">&#x27;../start-cluster&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>start-cluster</code>文件里主要源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = <span class="built_in">JSON</span>.parse(process.argv[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">require</span>(options.framework).startCluster(options);</span><br></pre></td></tr></table></figure><p>到此我们知道整个<code>egg-bin dev</code>想要做的事情只有两件：</p><ol><li>获取参数options，重点是options.framework，即找到要加载的框架</li><li>执行require(framework).startCluster()，加载框架并执行startCluster<br>回过头来继续看<code>lib/cmd/dev.js</code>，在<code>formatArgs</code>函数里我们找到获取framework的逻辑：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">&#x27;egg-utils&#x27;</span>);</span><br><span class="line">argv.framework = utils.getFrameworkPath(&#123;</span><br><span class="line">    <span class="attr">framework</span>: argv.framework,</span><br><span class="line">    <span class="attr">baseDir</span>: argv.baseDir,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>接下来我们去看下getFrameworkPath的实现逻辑。</li></ol><h2 id="egg-utils"><a href="#egg-utils" class="headerlink" title="egg-utils"></a>egg-utils</h2><p>在<code>lib/framework.js</code>里我们很容易找到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFrameworkPath</span>(<span class="params">&#123; framework, baseDir &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pkgPath = path.join(baseDir, <span class="string">&#x27;package.json&#x27;</span>);</span><br><span class="line">  assert(fs.existsSync(pkgPath), <span class="string">`<span class="subst">$&#123;pkgPath&#125;</span> should exist`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> moduleDir = path.join(baseDir, <span class="string">&#x27;node_modules&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> pkg = utility.readJSONSync(pkgPath);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. pass framework or customEgg</span></span><br><span class="line">  <span class="keyword">if</span> (framework) &#123;</span><br><span class="line">    <span class="comment">// 1.1 framework is an absolute path</span></span><br><span class="line">    <span class="comment">// framework: path.join(baseDir, &#x27;node_modules/$&#123;frameworkName&#125;&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> (path.isAbsolute(framework)) &#123;</span><br><span class="line">      <span class="keyword">return</span> framework;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.2 framework is a npm package that required by application</span></span><br><span class="line">    <span class="comment">// framework: &#x27;frameworkName&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> assertAndReturn(framework, moduleDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. framework is not specified</span></span><br><span class="line">  <span class="comment">// 2.1 use framework name from pkg.egg.framework</span></span><br><span class="line">  <span class="keyword">if</span> (pkg.egg &amp;&amp; pkg.egg.framework) &#123;</span><br><span class="line">    <span class="keyword">return</span> assertAndReturn(pkg.egg.framework, moduleDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2 use egg by default</span></span><br><span class="line">  <span class="keyword">return</span> assertAndReturn(<span class="string">&#x27;egg&#x27;</span>, moduleDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码详细讲述了获取framework的逻辑：</p><ol><li>首先看<code>npm run dev</code>执行时是否指定framework，有的话继续判断是否是绝对路劲，转为合适的格式返回</li><li>尝试读取package.json，查看是否有egg以及egg的framework配置</li><li>默认返回<code>egg</code></li></ol><p>这里我们看默认egg的情况，则forkNode执行的语句为<code>require(&#39;egg&#39;).startCluster(options)</code></p><h2 id="require-‘egg’-startCluster-options"><a href="#require-‘egg’-startCluster-options" class="headerlink" title="require(‘egg’).startCluster(options)"></a>require(‘egg’).startCluster(options)</h2><p>在egg的<code>index.js</code>文件的开头我们看到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start egg application with cluster mode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since </span>1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">exports</span>.startCluster = <span class="built_in">require</span>(<span class="string">&#x27;egg-cluster&#x27;</span>).startCluster;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很好，终于看到<code>egg-cluster</code>了。</p><h2 id="egg-cluster"><a href="#egg-cluster" class="headerlink" title="egg-cluster"></a>egg-cluster</h2><p>首先是<code>index.js</code>中暴露的startCluster方法，也是整个egg-cluster的入口方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.startCluster = <span class="function"><span class="keyword">function</span>(<span class="params">options, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Master(options).ready(callback);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，egg-cluster是一个Master实例，Master就显得至关重要了。<br>介绍master之前先梳理一下egg-cluster的目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">egg-cluster</span><br><span class="line">├── lib</span><br><span class="line">│   ├── utils</span><br><span class="line">│   │    ├── manager.js</span><br><span class="line">│   │    ├── messenger.js</span><br><span class="line">│   │    ├── options.js</span><br><span class="line">│   │    └── terminate.js</span><br><span class="line">│   ├── agent_worker.js</span><br><span class="line">│   ├── app_worker.js</span><br><span class="line">│   └── master.js</span><br><span class="line">├── index.js</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>先看master.js，下面截取出Master构造函数的关键代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.options = parseOptions(options);</span><br><span class="line"><span class="built_in">this</span>.workerManager = <span class="keyword">new</span> Manager();</span><br><span class="line"><span class="built_in">this</span>.messenger = <span class="keyword">new</span> Messenger(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">ready.mixin(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ready后的回调函数</span></span><br><span class="line"><span class="built_in">this</span>.ready(<span class="function">() =&gt;</span> &#123;...&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加监听事件，有agent-exit, agent-start, app-exit, app-start, reload-worker, realport</span></span><br><span class="line"><span class="built_in">this</span>.on(<span class="string">&#x27;...&#x27;</span>, <span class="function">() =&gt;</span> &#123;...&#125;)</span><br><span class="line"><span class="comment">// 一次性监听事件，启动appWorkers</span></span><br><span class="line"><span class="built_in">this</span>.once(<span class="string">&#x27;agent-start&#x27;</span>, <span class="built_in">this</span>.forkAppWorkers.bind(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// forkAgentWorker</span></span><br><span class="line">detectPort(<span class="function">(<span class="params">err, port</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.forkAgentWorkder();  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听agent、workder异常</span></span><br><span class="line"><span class="built_in">this</span>.workerManager.on(<span class="string">&#x27;exception&#x27;</span>, <span class="function">()=&gt;</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure><p>从上往下执行，首先是parseOptions，这个函数是<code>lib/utils/options.js</code>，用来解析并返回正确格式的options</p><h3 id="options-js"><a href="#options-js" class="headerlink" title="options.js"></a>options.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> defaults = &#123;</span><br><span class="line">        <span class="attr">framework</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">baseDir</span>: process.cwd(),</span><br><span class="line">        <span class="attr">port</span>: options.https ? <span class="number">8443</span> : <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">workers</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">plugins</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">https</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    options = extend(defaults, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码片段仅截取部分，显示options的各个属性，和egg-bin dev提供的基本一致。具体的略过不讲。<br>接下来是new Manager();</p><h3 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h3><p>将manager.js里的属性和方法简单画成UML图形如下：</p><p><img data-src="https://kaola-haitao.oss.kaolacdn.com/769ea022-22ba-4861-80c6-ebf837f6e429_176_315.svg" alt="image"></p><p>Manager主要是用于管理agent和worker，有两个方法比较特殊，分别是count()和startCheck()，count()返回agent和worker的数量，而startCheck()每10秒执行一次，判断count返回的agent和worker数量是否大于0，出现3次异常，则发出exception事件，并不再执行。</p><h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p>将messenger.js里的属性和方法简单画成UML图如下：</p><p><img data-src="https://kaola-haitao.oss.kaolacdn.com/8347fbea-a656-4971-ab24-9eb8a43e05cb_189_143.svg" alt="image"></p><p>Messenger类</p><ul><li>send: 做了一些from和to的处理工作，并根据from和to，调用其他四个方法。</li><li>sendToMaster: 使用的是this.master.emit方法，Master本身就是继承于EventEmitter，直接调用emit方法，使用master.on既可以监听到。</li><li>sendToParent: 调用的是process.send()</li></ul><blockquote><p>If Node.js is spawned with an IPC channel, the process.send() method can be used to send messages to the parent process. Messages will be received as a ‘message’ event on the parent’s ChildProcess object.</p></blockquote><ul><li>sendToAppWorker: 调用的是<a href="https://npm.taobao.org/package/sendmessage">sendmessage</a>(worker, data);</li><li>sendToAgentWorker: 调用的是sendmessage(agentWorker, data);</li></ul><blockquote><p>sendmessage(childprocess, message): Send a cross process message. If a process is not child process, this will just call process.emit(‘message’, message) instead.</p></blockquote><h3 id="terminate-js"><a href="#terminate-js" class="headerlink" title="terminate.js"></a>terminate.js</h3><p>terminate.js文件主要用于终止进程，这里不再赘述。</p><h3 id="启动agentWorker，agent-worker-js"><a href="#启动agentWorker，agent-worker-js" class="headerlink" title="启动agentWorker，agent_worker.js"></a>启动agentWorker，agent_worker.js</h3><p>回到Master的构造函数中，从之前整理出的代码片段来看，实例化manager，messenger之后，注册ready的回调函数，接下来就是启动agent进程了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">forkAgentWorker</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> agentWorker = child_process.fork(<span class="string">&#x27;lib/agent_worker.js&#x27;</span>, args, opt);</span><br><span class="line">    <span class="built_in">this</span>.workerManager.setAgent(agentWorker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面片段仅截取关键部分。可以看出使用了node的原生模块<code>child_process</code>的fork方法。下面继续看<code>agent_worker.js</code>;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Agent = <span class="built_in">require</span>(options.framework).Agent;</span><br><span class="line"><span class="keyword">const</span> agent = <span class="keyword">new</span> Agent(options);</span><br><span class="line"></span><br><span class="line">agent.ready(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// don&#x27;t send started message to master when start error</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  agent.removeListener(<span class="string">&#x27;error&#x27;</span>, startErrorHandler);</span><br><span class="line">  process.send(&#123; <span class="attr">action</span>: <span class="string">&#x27;agent-start&#x27;</span>, <span class="attr">to</span>: <span class="string">&#x27;master&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从上面可以看到agentWorker实例了framework的Agent，而根据之前的分析，framework默认情况下是egg，这里为了简化分析，将framework认为是egg，那可以认为这个子进程执行了new Agent(options)操作；并且在ready回调中向master进程发送<code>agent-start</code>消息。而发送的这个消息则至关重要，master进程中对于它的监听回调函数中执行了worker进程的fork。</p><h3 id="启动appWorker，app-worker-js"><a href="#启动appWorker，app-worker-js" class="headerlink" title="启动appWorker，app_worker.js"></a>启动appWorker，app_worker.js</h3><p>仍然回到Master的构造函数那里，可以看到</p><blockquote><p>this.once(‘agent-start’, this.forkAppWorkers.bind(this));</p></blockquote><p>当agentWorker进程启动ready后，发送agent-start消息给master进程，master进程第一次收到后执行forkAppWorkers();</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">forkAppWorkers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cfork(&#123;</span><br><span class="line">      <span class="attr">exec</span>: <span class="built_in">this</span>.getAppWorkerFile(),</span><br><span class="line">      args,</span><br><span class="line">      <span class="attr">silent</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">count</span>: <span class="built_in">this</span>.options.workers,</span><br><span class="line">      <span class="comment">// don&#x27;t refork in local env</span></span><br><span class="line">      <span class="attr">refork</span>: <span class="built_in">this</span>.isProduction,</span><br><span class="line">    &#125;);</span><br><span class="line">    cluster.on(<span class="string">&#x27;fork&#x27;</span>, <span class="function"><span class="params">worker</span> =&gt;</span> &#123;...&#125;);</span><br><span class="line">    cluster.on(<span class="string">&#x27;listening&#x27;</span>, <span class="function">(<span class="params">worker, address</span>) =&gt;</span> &#123;...&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://npm.taobao.org/package/cfork">cfork</a> npm包，使用原生cluster的setupMaster方法和fork方法。对cfork感兴趣的童鞋可以去<a href="https://163.lu/k/htryK3">看</a></p><blockquote><p>cluster fork and restart easy way</p></blockquote><p>我们接着看简化版的app_worker.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Application = <span class="built_in">require</span>(options.framework).Application;</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Application(options);</span><br><span class="line">process.send(&#123; <span class="attr">to</span>: <span class="string">&#x27;master&#x27;</span>, <span class="attr">action</span>: <span class="string">&#x27;realport&#x27;</span>, <span class="attr">data</span>: port &#125;);</span><br><span class="line">app.ready(startServer);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startServer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    server.require(<span class="string">&#x27;http&#x27;</span>).createServer(app.callback());</span><br><span class="line">    server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以知道，app_worker中执行了new Application()，并使用原生http（或https）模块启动一个server。当server执行listen方法时，触发了master中 forkAppWorkers方法中注册的listening回调事件</p><blockquote><p>cluster.on(‘listening’, (worker, address) =&gt; {…});</p></blockquote><p>该回调事件中向maste发送了<code>app-start</code>事件。<br><code>app-start</code>的回调函数中在最后执行了</p><blockquote><p>this.ready(true);（这里使用了<a href="http://npm.hz.netease.com/package/get-ready">get-ready</a>， 构造函数中通过<code>ready.mixin(this);</code>，注入ready方法，并添加回调函数）</p></blockquote><p>这一句会触发master构造函数中注册的ready回调函数。该回调函数中将isStarted设置成true， 并想parent，app，agent发送<code>egg-ready</code>事件。</p><p>到这里启动就基本完成了。<br>启动的时序正如官方文档所描述的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+---------+           +---------+          +---------+</span><br><span class="line">|  Master |           |  Agent  |          |  Worker |</span><br><span class="line">+---------+           +----+----+          +----+----+</span><br><span class="line">     |      fork agent     |                    |</span><br><span class="line">     +--------------------&gt;|                    |</span><br><span class="line">     |      agent ready    |                    |</span><br><span class="line">     |&lt;--------------------+                    |</span><br><span class="line">     |                     |     fork worker    |</span><br><span class="line">     +-----------------------------------------&gt;|</span><br><span class="line">     |     worker ready    |                    |</span><br><span class="line">     |&lt;-----------------------------------------+</span><br><span class="line">     |      Egg ready      |                    |</span><br><span class="line">     +--------------------&gt;|                    |</span><br><span class="line">     |      Egg ready      |                    |</span><br><span class="line">     +-----------------------------------------&gt;|</span><br></pre></td></tr></table></figure><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>本文只是简单的从源码角度大致梳理了egg启动过程中的做的一些事情，很多东西还需要进一步深入研究，比如<code>agent_worker.js</code>使用的是<code>child_process</code>的fork方法，而<code>app_worker.js</code>使用的是cfork（使用的是原生的cluster的fork），需要研究下child_process和cluster。此外，本文还没涉及到Agent和Application的具体的实现，Agent和Application都是基于EggApplication，而EggApplication是基于EggCore的，EggCore继承于Koa。等等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JavaScript代码是单线程运行的，因而一旦有未捕获的异常抛出线程就会挂掉，业务也就不可访问了，所以一般我们在使用koa，express，thinkjs等其他node框架时一般会使用pm2去管理node进程，保证业务的高可用性。而阿里开源的egg框架本身自带的egg-cluster模板已经帮我们做了这个事情，egg的多进程模型和进程间通信官方文档上写的已经很清楚了，今天学习一下源码，希望有所收获。&lt;/p&gt;
&lt;h2 id=&quot;egg-bin-dev&quot;&gt;&lt;a href=&quot;#egg-bin-dev&quot; class=&quot;headerlink&quot; title=&quot;egg-bin dev&quot;&gt;&lt;/a&gt;egg-bin dev&lt;/h2&gt;&lt;p&gt;运行一个egg项目，&lt;code&gt;npm run dev&lt;/code&gt;在package.json文件里我们发现默认其实执行的是&lt;code&gt;egg-bin dev&lt;/code&gt;。egg-bin原来是egg提供的一个开发时使用的命令行工具，翻开egg-bin的代码，我们可以看到egg-bin其实是基于&lt;a href=&quot;http://npm.taobao.org/package/common-bin&quot;&gt;common-bin&lt;/a&gt;开发的，这里不赘述common-bin的用法，感兴趣的童鞋自行去查阅。在&lt;code&gt;lib/cmd/dev.js&lt;/code&gt;里我们可以看到&lt;code&gt;egg-bin dev&lt;/code&gt;执行的逻辑（去掉debug日志）：&lt;/p&gt;</summary>
    
    
    
    
    <category term="eggjs" scheme="http://soonwang.cn/tags/eggjs/"/>
    
    <category term="javascript" scheme="http://soonwang.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vue.$nextTick浅谈</title>
    <link href="http://soonwang.cn/2018/08/05/Vue.$nextTick/"/>
    <id>http://soonwang.cn/2018/08/05/Vue.$nextTick/</id>
    <published>2018-08-05T20:02:11.000Z</published>
    <updated>2021-07-20T02:43:14.064Z</updated>
    
    <content type="html"><![CDATA[<p>依稀记得第一次接触Vue.$nextTick是在之前某个项目从Vue 1.x升级到Vue 2.x时，发现vue实例的生命周期钩子函数都变了。查阅Vue官方提供的升级文档时发现，ready被mounted钩子函数替代，文档还特别提出，mounted并不保证钩子函数中的this.$el在document中，需要使用vm.$nextTick，那时起就觉得$nextTick好神奇。今天就来谈（xia）谈（che）Vue的异步实现$nextTick。</p><h2 id="0-浏览器事件循环机制"><a href="#0-浏览器事件循环机制" class="headerlink" title="0 浏览器事件循环机制"></a>0 浏览器事件循环机制</h2><p>在谈$nextTick之前，当然要先温习一下浏览器的事件循环啦。ps：各位对浏览器事件循环机制了如指掌的看官可以直接跳过了。</p><h3 id="0-1-单线程和异步"><a href="#0-1-单线程和异步" class="headerlink" title="0.1 单线程和异步"></a>0.1 单线程和异步</h3><p>我们都知道js是单线程的，js引擎负责解释执行js的只有一个线程，就是我们所谓的主线程，而一些异步回调函数会被放到任务队列中，当主线程空闲时，会执行任务队列中的回调函数。</p><h3 id="0-2-tasks-macroTasks-和-microTasks"><a href="#0-2-tasks-macroTasks-和-microTasks" class="headerlink" title="0.2 tasks (macroTasks) 和 microTasks"></a>0.2 tasks (macroTasks) 和 microTasks</h3><p>event loop中有两种类型的任务队列，tasks（macroTasks）和mircroTasks。</p><ul><li>tasks: 执行主线程js代码、网络请求、页面加载、输入、点击事件以及定时器事件（setTimeout,setIntervel,setImmediate）等。</li><li>microTasks: 更新应用程序状态的任务，常见的有promise，process.nextTick，MutationObserver，Object.observe等</li></ul><span id="more"></span><h3 id="0-3-来做个题吧"><a href="#0-3-来做个题吧" class="headerlink" title="0.3 来做个题吧"></a>0.3 来做个题吧</h3><p>先看下面的js代码，写出执行执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;script start&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;);</span><br><span class="line">  Promise.resolve().then(function()&#123;</span><br><span class="line">      console.log(&#x27;promise in setTimeout&#x27;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;);</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;setTimeout in promise1&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&#x27;promise2&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;script end&#x27;);</span><br></pre></td></tr></table></figure><h3 id="0-4-event-loop-处理顺序"><a href="#0-4-event-loop-处理顺序" class="headerlink" title="0.4 event loop 处理顺序"></a>0.4 event loop 处理顺序</h3><p>ps: 觉得毫无难度的大大可以跳过了。<br>执行的结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br><span class="line">promise <span class="keyword">in</span> setTimeout</span><br><span class="line">setTimeout <span class="keyword">in</span> promise1</span><br></pre></td></tr></table></figure><p>先看下“圣经”的解释（颤颤抖抖打开为<a href="https://www.w3.org/TR/2017/REC-html52-20171214/webappapis.html#event-loops-processing-model">w3c</a>）</p><blockquote><ol><li>Select the oldest task on one of the event loop’s task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue. If there is no task to select, then jump to the Microtasks step below.</li><li>Set the event loop’s currently running task to the task selected in the previous step.</li><li>Run: Run the selected task.</li><li>Set the event loop’s currently running task back to null.</li><li>Remove the task that was run in the Run step above from its task queue.</li><li>Microtasks: Perform a microtask checkpoint.</li><li>Update the rendering: If this event loop is a browsing context event loop (as opposed to a Worker event loop), then run the following substeps.（此处省略，感兴趣的大佬请移步w3c）</li><li>If this is a Worker event loop (i.e., one running for a WorkerGlobalScope), but there are no tasks in the event loop’s task queues and the WorkerGlobalScope object’s closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps.</li><li>Return to the first step of the event loop.</li></ol></blockquote><p>好了，上面解释的很清楚了，我就不翻译了（各位大大英语肯定都比我好，逃）<br>下面放上一张网上盗的图<br><img data-src="https://kaola-haitao.oss.kaolacdn.com/7957a9f2-0988-4d29-a87f-39956c294552_436_529.jpg" alt="image"></p><p>总结起来就是，在一次事件循环里</p><ul><li>先判断macroTask queue是否为空，空的话直接下一步，不为空的话只取出一个task执行，执行完下一步</li><li>再判断microTask queue是否为空，空的话直接下一步，不为空的话会取出一个task执行，执行完重复这一步，直到队列为空</li><li>更新渲染</li></ul><h2 id="1-Vue-nextTick"><a href="#1-Vue-nextTick" class="headerlink" title="1. Vue.$nextTick"></a>1. Vue.$nextTick</h2><h3 id="1-1-nextTick-使用"><a href="#1-1-nextTick-使用" class="headerlink" title="1.1  nextTick 使用"></a>1.1  nextTick 使用</h3><p>这里引用一下Vue官网文API上的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 修改数据</span><br><span class="line">vm.msg = &#x27;Hello&#x27;</span><br><span class="line">// DOM 还没有更新</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  // DOM 更新了</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(function () &#123;</span><br><span class="line">    // DOM 更新了</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p></blockquote><p>为什么在修改了数据之后DOM没有立即更新，而立即使用nextTick就能在回调里获取到更新后的DOM呢。带着这样的疑问我们先去看下nextTick的实现。</p><h3 id="1-2-nextTick-实现"><a href="#1-2-nextTick-实现" class="headerlink" title="1.2 nextTick 实现"></a>1.2 nextTick 实现</h3><p>目前我看的vue代码版本是2.5.17-beta.0，此版本中nextTick的实现在 <code>src/core/util/next-tick.js</code>中。源码100+行，这里就不贴了，感兴趣的童鞋请<a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js">移步</a>。<br>nextTick文件暴露了两个函数，nextTick和witchMacroTask。先看nextTick</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">export function nextTick (cb?: Function, ctx?: Object) &#123;</span><br><span class="line">  let _resolve</span><br><span class="line">  callbacks.push(() =&gt; &#123;</span><br><span class="line">    if (cb) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, ctx, &#x27;nextTick&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending = true</span><br><span class="line">    if (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // $flow-disable-line</span><br><span class="line">  if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先判断cb是否存在，存在则返回callbacks数组里</li><li>判断!pending，即判断上一次异步回调是否已执行，若已执行，再判断是否使用macroTask（默认不），决定添加到macroTask还是microTask</li><li>如果cb不存在且浏览器支持Promise，则返回Promise</li></ol><p>next-tick文件里有个变量 <code>callbacks</code>, <code>callbacks</code>是一个任务队列，nextTick会把cb都放入到这个队列里。使用callbacks而不是在nextTick中直接执行回调函数的原因是保证在同一个nexTick内执行完之前tick的所有异步任务，将多个异步任务压成一个同步任务，在下一个tick执行完毕。</p><p>flushCallbacks用于遍历callbacks并执行回调，并将pending设置为false，表示可以开始下一个tick。</p><p>macroTimerFunc会依次从setImmediate，MessageChannel，setTimeout中取，而microTimerFunc则先检测浏览器是否原生支持Promise，不支持则指向macroTimerFunc的实现。这两个函数中都会异步调用flushCallbacks，默认使用microTimerFunc。</p><p>看到这里，我们大概知道了nextTick做的事情了，可是之前的疑问还是没有得到答案啊，为什么修改了数据之后，需要在下一个tick里才会更新呢？好吧，接下来再去扒一扒源码。</p><h2 id="2-响应式原理"><a href="#2-响应式原理" class="headerlink" title="2. 响应式原理"></a>2. 响应式原理</h2><p>Vue使用Object.defineProperty把对象的属性转为getter/setter，这是响应式的核心，也是Vue不支持IE8以及更低版本浏览器的原因。下面是从官网盗的一张图。<br><img data-src="https://kaola-haitao.oss.kaolacdn.com/58ee9280-643d-45e7-86dd-2f9f2726ff13_1200_750.png" alt="image"></p><p>从上图可以知道，Data变化之后会Notify Watcher，而Watcher又会触发re-render。哦，原来是这样，但是还是不知道为什么修改Data之后一定要nextTick，Dom才会更新啊，继续低头扒代码…</p><h3 id="2-1-Observer"><a href="#2-1-Observer" class="headerlink" title="2.1 Observer"></a>2.1 Observer</h3><p>Vue的Observer类的实现在<code>src/core/observer/index.js</code>，为了省点墨水这里就不填代码了，少侠请<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js">移步</a>。</p><p><img data-src="https://kaola-haitao.oss.kaolacdn.com/c1bb3289-6c83-4279-b2eb-559600384d20_2118_1262.jpg" alt="image"></p><p>上面这张图是我根据代码画的（这么丑一看就知道肯定自己画的，凑合着看）。</p><p>Observer类的主要作用是给对象的属性添加getter和setter，收集依赖和派发更新。<br>defineReactive方法最为重要，它就实现了给对象属性添加getter和setter，收集依赖和派发更新。下面截取关键的源码（有删减）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">let childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        if (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          if (Array.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      if (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，defineReactive在getter和setter方法中分别实现了依赖收集和更新派发。</p><p>getter中执行完原getter之后，先判断Dep.target，在dep.depend()，并把val也都设置成响应式并收集了依赖。厉害啊！哎等等，Dep.target是什么？为什么要先判断这个呢？</p><p>setter中先判断val是否有改变，执行完原setter后（将newVal也设成响应式），dep.notify()。奥，仿佛明白了什么…</p><p>哎喂，Dep是什么？一开始都没说啊，从哪冒出来的？别急，我们接着看</p><h3 id="2-2-Dep"><a href="#2-2-Dep" class="headerlink" title="2.2 Dep"></a>2.2 Dep</h3><p>Dep类的实现在<code>src/core/observer/dep.js</code>，照例，少侠请<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/dep.js">移步</a>。</p><p>照例，上图</p><p><img data-src="https://kaola-haitao.oss.kaolacdn.com/a628c51f-1321-4228-8938-b5b2321d346f_800_1072.jpg" alt="image"></p><p>图上很明显（强行很明显），能找到上面Observer defineReactive方法用到的那几个方法，depend,notify,以及静态属性Dep.target，这下全明白了吧？并没有，Dep.target默认是null，不可能一直是null的呀，一直是null的话，那defineReactive的判断永远不会true啊。还有，subs是啥，notify里怎么还能update呢？哎，接着看吧emmmmm…</p><h3 id="2-3-Watcher"><a href="#2-3-Watcher" class="headerlink" title="2.3 Watcher"></a>2.3 Watcher</h3><p>Watcher类的实现在<code>src/core/observer/watcher.js</code>，你懂的，请<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js">移步</a>。</p><p><img data-src="https://kaola-haitao.oss.kaolacdn.com/95ab0e44-2624-46fb-8fd6-f0c0f0313ba8_2326_1596.jpg" alt="image"></p><p>Watcher有众多属性，其中deep,computed,user,sync,before对某些流程会有些影响的。对于普通的Watcher（非computed），constructor时会执行get方法。</p><p>get方法里我们一眼看到了pushTarget(this)，popTarget()，正是上面Dep中所看到的。讲道理，在Observer的defineReactive方法中，getter时判断Dep.target是否为空，不为空才会收集依赖，而此处成对出现的pushTarget和popTarget仿佛就是告诉我们，get方法里，pushTarget和popTarget中间肯定会执行Observer的getter。为了方便解释，贴一下get的代码（有删减）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pushTarget(this)</span><br><span class="line">let value</span><br><span class="line">const vm = this.vm</span><br><span class="line">try &#123;</span><br><span class="line">    value = this.getter.call(vm, vm)</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    throw e</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    popTarget()</span><br><span class="line">    this.cleanupDeps()</span><br><span class="line">&#125;</span><br><span class="line">return value</span><br></pre></td></tr></table></figure><p>看过来看过去，最可疑的就是try的那一句 <code>this.getter.call(vm, vm)</code>。看下constructor中，原来this.getter是从expOrFn来的，是构造函数的第二个参数。这里先看到这里，继续看。<br>addDep，在Dep类的depend方法中，就是调用Dep.target.addDep方法，当Watcher get方法中pushTarget(this)，这个时候我们知道，此时Dep.target就是Watcher实例，addDep也就是这里addDep方法。<br>addDep将Dep的实例放入到Watcher实例的newDeps数组中，并将当前Watcher实例放入Dep实例的subs中（做了去重），实现依赖收集（好像有点绕）。</p><p>接下来重点来了，update方法，Dep的notify方法就是调用sub的update方法，也就是这里的update方法，定睛一看，对于普通watcher（非computed、非sync）来说，update调用的就是<code>queueWatcher(this)</code>；贴代码（删除注释）为证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  if (this.computed) &#123;</span><br><span class="line">    if (this.dep.subs.length === 0) &#123;</span><br><span class="line">      this.dirty = true</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.getAndInvoke(() =&gt; &#123;</span><br><span class="line">        this.dep.notify()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (this.sync) &#123;</span><br><span class="line">    this.run()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    queueWatcher(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那<code>queueWatcher</code>又是啥玩意呢，看到queue感到莫名的兴奋，觉得答案就在眼前！</p><h3 id="2-4-queueWatcher"><a href="#2-4-queueWatcher" class="headerlink" title="2.4 queueWatcher"></a>2.4 queueWatcher</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export function queueWatcher (watcher: Watcher) &#123;</span><br><span class="line">  const id = watcher.id</span><br><span class="line">  if (has[id] == null) &#123;</span><br><span class="line">    has[id] = true</span><br><span class="line">    if (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // if already flushing, splice the watcher based on its id</span><br><span class="line">      // if already past its id, it will be run next immediately.</span><br><span class="line">      let i = queue.length - 1</span><br><span class="line">      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + 1, 0, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    // queue the flush</span><br><span class="line">    if (!waiting) &#123;</span><br><span class="line">      waiting = true</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，按捺不住内心的欢喜，直接贴上了代码（连注释都来不及删了）。从下往上看，果然我看到了nextTick。接着看queueWatcher做了什么（源码请移步<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/scheduler.js">scheduler</a>）</p><ul><li>看watcher是否已在队列，不在继续执行（在的话返回）</li><li>当前没有执行flush队列时，直接将watcher push到队列里，否则安装watch id的大小插入到队列里的相应位置（flush队列时会先排序在执行，这里插到对应位置防止顺序乱了）。</li><li>如果当前不在flush或者flush已结束，则开始新的flush，nextTick(flushSchedulerQueue)。</li><li>flushSchedulerQueue 里先按watcher id大小排序，执行watcher.run()，最后执行active 和 update的钩子函数。</li></ul><p>到这里我们好像知道了答案，修改Data之后，通知到watcher更新时，使用了nextTick去执行队列。</p><p>到此结束了吗？当然还没完啊，还记得那年大明湖畔的夏雨荷吗？啊呸，还记得Watcher get方法里的getter方法，到底是不是getter里执行到了Observer。哦，假装不记得的童鞋可以散了先。</p><h2 id="3-Vue-实例"><a href="#3-Vue-实例" class="headerlink" title="3. Vue 实例"></a>3. Vue 实例</h2><p>废话不多说，先上图</p><p><img data-src="https://kaola-haitao.oss.kaolacdn.com/d6b0b8fb-d4e2-4a90-a8d3-fb9f987b6008_2144_1510.svg" alt="image"></p><p><code>src/core/instance/index.js</code>是Vue实例的入口，Vue.prototype._init定义在<code>src/core/instance/init.js</code>，<code>_init</code>的在最后执行<code>vm.$mount()</code>,这里是将vue实例挂载到dom上的关键一步。</p><p>在<code>src/platforms/web/runtime/index.js</code>找到一处Vue.prototype.$mount定义（vue的编译入口有多个），这里的$mount实际调用的是<code>src/core/instance/lifecycle.js</code>中的mountComponent方法，这个方法里果然看到了两个重要的生命周期钩子函数的调用，根据Vue官网文档说明，Vue实例的挂载就应该是在两个钩子函数之间，上代码（关键代码）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = () =&gt; &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;</span><br><span class="line">new Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">  before () &#123;</span><br><span class="line">    if (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, &#x27;beforeUpdate&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, true /* isRenderWatcher */)</span><br></pre></td></tr></table></figure><p>很明显，mountComponent里调用new Watcher()生成一个renderWatcher，传入的getter正是updateComponent，updateComponent里调用<code>vm._update(vm._render())</code>，继续追查。</p><p>在<code>src/core/instance/render.js</code>中找到<code>Vue.prototype._render</code>的定义，原来<code>_render</code>调用的是<code>vm.$createElement</code>，而<code>vm.$createElement</code>定义在initRender中，使用的<code>src/core/vdom/create-element.js</code>。好了绕了一大圈终于找到了，从代码上看，createElement最终返回的是一个vnode，而在vnode的constructor里进行赋值就会触发Data的getter，getter里的Dep.target此时正是刚new的renderWatcher，依赖收集完成（在vue实例的iniMixin已经执行过initData，data早就是响应式的了）。</p><p>修改数据触发更新时，renderWatcher会被push进queue里，nextTick时renderWatcher调用run方法，run方法调用getAndInvoke方法，而getAndInvoke方法会调用get方法，get方法则会执行getter，也就是updateComponent，<code>vm._render()</code>返回一个新vnode，而<code>vm._update</code>会调用<code>vm.__patch__(preVnode, vnode)</code>，重新渲染。</p><p>好了，终于理（che）完了。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://ustbhuangyi.github.io/vue-analysis/">Vue.js技术揭秘</a></li><li><a href="http://lynnelv.github.io/js-event-loop-browser">深入理解js事件循环机制（浏览器篇）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;依稀记得第一次接触Vue.$nextTick是在之前某个项目从Vue 1.x升级到Vue 2.x时，发现vue实例的生命周期钩子函数都变了。查阅Vue官方提供的升级文档时发现，ready被mounted钩子函数替代，文档还特别提出，mounted并不保证钩子函数中的this.$el在document中，需要使用vm.$nextTick，那时起就觉得$nextTick好神奇。今天就来谈（xia）谈（che）Vue的异步实现$nextTick。&lt;/p&gt;
&lt;h2 id=&quot;0-浏览器事件循环机制&quot;&gt;&lt;a href=&quot;#0-浏览器事件循环机制&quot; class=&quot;headerlink&quot; title=&quot;0 浏览器事件循环机制&quot;&gt;&lt;/a&gt;0 浏览器事件循环机制&lt;/h2&gt;&lt;p&gt;在谈$nextTick之前，当然要先温习一下浏览器的事件循环啦。ps：各位对浏览器事件循环机制了如指掌的看官可以直接跳过了。&lt;/p&gt;
&lt;h3 id=&quot;0-1-单线程和异步&quot;&gt;&lt;a href=&quot;#0-1-单线程和异步&quot; class=&quot;headerlink&quot; title=&quot;0.1 单线程和异步&quot;&gt;&lt;/a&gt;0.1 单线程和异步&lt;/h3&gt;&lt;p&gt;我们都知道js是单线程的，js引擎负责解释执行js的只有一个线程，就是我们所谓的主线程，而一些异步回调函数会被放到任务队列中，当主线程空闲时，会执行任务队列中的回调函数。&lt;/p&gt;
&lt;h3 id=&quot;0-2-tasks-macroTasks-和-microTasks&quot;&gt;&lt;a href=&quot;#0-2-tasks-macroTasks-和-microTasks&quot; class=&quot;headerlink&quot; title=&quot;0.2 tasks (macroTasks) 和 microTasks&quot;&gt;&lt;/a&gt;0.2 tasks (macroTasks) 和 microTasks&lt;/h3&gt;&lt;p&gt;event loop中有两种类型的任务队列，tasks（macroTasks）和mircroTasks。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tasks: 执行主线程js代码、网络请求、页面加载、输入、点击事件以及定时器事件（setTimeout,setIntervel,setImmediate）等。&lt;/li&gt;
&lt;li&gt;microTasks: 更新应用程序状态的任务，常见的有promise，process.nextTick，MutationObserver，Object.observe等&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="javascript" scheme="http://soonwang.cn/tags/javascript/"/>
    
    <category term="Vue" scheme="http://soonwang.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>kali2安装vnc server记录</title>
    <link href="http://soonwang.cn/2018/01/12/kali-install-vncsever/"/>
    <id>http://soonwang.cn/2018/01/12/kali-install-vncsever/</id>
    <published>2018-01-12T19:13:48.000Z</published>
    <updated>2021-07-20T02:43:14.064Z</updated>
    
    <content type="html"><![CDATA[<p>在kali2上安装vnc server的过程中遇到一些问题，记录总结下</p><ul><li>安装vnc server，选择vnc4server，执行命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vnc4server</span><br></pre></td></tr></table></figure></li><li>首次启动vncserver 执行命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vncserver</span><br></pre></td></tr></table></figure></li><li>首次启动，需要输入密码和验证密码，以及一个是否设置【只读】密码，会保存在~/.vnc/passwd中</li><li>启动时，往往会报错，此时在~/.vnc/中查看是否有xstartup文件，没有新增一个，默认可以写入<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.vnc/xstartup </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">xterm &amp;</span><br></pre></td></tr></table></figure></li><li>在vnc viewer中连接vnc server，ip+桌面号或者端口号，</li></ul><span id="more"></span><h2 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h2><h3 id="vnc-viewer连接问题"><a href="#vnc-viewer连接问题" class="headerlink" title="vnc viewer连接问题"></a>vnc viewer连接问题</h3><p>此时一般会有两种异常情况</p><ol><li>一种是timeout，等待很长时间，然后提示超时，这种情况要检查网络，vnc server所在主机是否开放相应的端口（linux可以使用ufw管理软件）；</li><li>另一种异常是refused，可以尝试使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet &#123;ip&#125; &#123;port&#125;</span><br></pre></td></tr></table></figure>远程测试vnc server所在主机是否refused，如果refused，ssh远程登录到该主机，使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 &#123;port&#125;</span><br></pre></td></tr></table></figure>测试，会发现此时是可以连接的。这种异常需要在vncserver启动时加上<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-localhost no</span><br></pre></td></tr></table></figure>参数即可</li></ol><h3 id="vnc-viewer连接之后的显示问题"><a href="#vnc-viewer连接之后的显示问题" class="headerlink" title="vnc viewer连接之后的显示问题"></a>vnc viewer连接之后的显示问题</h3><p>若使用上面提供的xstartup代码，连接之后会发现只有个终端，这个效果肯定不是我们希望的，甚至还不如直接ssh登录呢！所以，要搞出桌面。</p><ul><li>安装桌面<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-core xfce4</span><br></pre></td></tr></table></figure></li><li>配置~/.vnc/xstartup文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">unset</span> SESSION_MANAGER</span><br><span class="line"><span class="built_in">unset</span> DBUS_SESSION_BUS_ADDRESS</span><br><span class="line">startxfce4 &amp;</span><br><span class="line">[ -x /etc/vnc/xstartup ] &amp;&amp; <span class="built_in">exec</span> /etc/vnc/xstartup</span><br><span class="line">[ -r <span class="variable">$HOME</span>/.Xresources ] &amp;&amp; xrdb <span class="variable">$HOME</span>/.Xresources</span><br><span class="line">xsetroot -solid grey</span><br><span class="line">vncconfig -iconic &amp;</span><br></pre></td></tr></table></figure><ul><li>重启vncserver，关闭vncsever命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vncserver -<span class="built_in">kill</span> :number</span><br></pre></td></tr></table></figure>其中number表示桌面号，<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vncserver -localhost no</span><br></pre></td></tr></table></figure>启动。</li></ul><h3 id="vnc-server启动失败问题"><a href="#vnc-server启动失败问题" class="headerlink" title="vnc server启动失败问题"></a>vnc server启动失败问题</h3><p>在执行一个vncserver关闭命令之后，可能下次启动会提示失败，查看日志，提示类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fatal server error:</span><br><span class="line">(EE) Cannot establish any listening sockets - Make sure an X server isn<span class="string">&#x27;t already running(EE)</span></span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/.X11-unit/</span><br></pre></td></tr></table></figure><p>接着</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -C Xorg</span><br></pre></td></tr></table></figure><p>kill掉显示的进程即可。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="vnc-viewer连接的窗口大小、分辨率"><a href="#vnc-viewer连接的窗口大小、分辨率" class="headerlink" title="vnc viewer连接的窗口大小、分辨率"></a>vnc viewer连接的窗口大小、分辨率</h3><p>在vnc server 启动时加上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-geometry 1366x768</span><br></pre></td></tr></table></figure><p>类似参数</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在kali2上安装vnc server的过程中遇到一些问题，记录总结下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装vnc server，选择vnc4server，执行命令&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install vnc4server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;首次启动vncserver 执行命令 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo vncserver&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;首次启动，需要输入密码和验证密码，以及一个是否设置【只读】密码，会保存在~/.vnc/passwd中&lt;/li&gt;
&lt;li&gt;启动时，往往会报错，此时在~/.vnc/中查看是否有xstartup文件，没有新增一个，默认可以写入&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cat ~/.vnc/xstartup &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xterm &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;在vnc viewer中连接vnc server，ip+桌面号或者端口号，&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="kali" scheme="http://soonwang.cn/tags/kali/"/>
    
    <category term="vnc server" scheme="http://soonwang.cn/tags/vnc-server/"/>
    
  </entry>
  
  <entry>
    <title>对象创建模式创建--沙盒模式</title>
    <link href="http://soonwang.cn/2017/02/21/sandbox-pattern/"/>
    <id>http://soonwang.cn/2017/02/21/sandbox-pattern/</id>
    <published>2017-02-21T13:38:23.000Z</published>
    <updated>2021-07-20T02:43:14.064Z</updated>
    
    <content type="html"><![CDATA[<p>看汤姆大叔的博客，记录一下对象创建模式里的沙盒模式<br>沙盒模式即是为一个或多个模块提供单独的上下文环境，而不会影响其他模块的上下文环境，比如有个Sandbox里有3个方法event，dom，ajax，在调用其中2个组成一个环境的话，和调用三个组成的环境完全没有干扰。Sandbox实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sandbox</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">    <span class="comment">//最后一个参数为callback</span></span><br><span class="line">    callback = args.pop(),</span><br><span class="line">    <span class="comment">//除最后一个参数外，其他均为要选择的模块</span></span><br><span class="line">    modules = (args[<span class="number">0</span>] &amp;&amp; <span class="keyword">typeof</span> args[<span class="number">0</span>] === <span class="string">&#x27;string&#x27;</span>) ? args : args[<span class="number">0</span>],</span><br><span class="line">    i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//强制使用new 操作符</span></span><br><span class="line">    <span class="keyword">if</span>(!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Sandbox)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Sandbox(modules, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加属性</span></span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向this对象上添加模块</span></span><br><span class="line">    <span class="comment">//如果没有传模块或者传入的参数为&quot;*&quot;，则认为传入所有模块</span></span><br><span class="line">    <span class="keyword">if</span>(!modules || modules == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">      modules = [];</span><br><span class="line">      <span class="keyword">for</span>(i <span class="keyword">in</span> Sandbox.moduls) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Sandbox.modules.hasOwnProperty(i)) &#123;</span><br><span class="line">          modules.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化需要的模块</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;modules.length; i+=<span class="number">1</span>) &#123;</span><br><span class="line">      Sandbox.modules[modules[i]](<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用callback</span></span><br><span class="line">    callback(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认添加原型对象</span></span><br><span class="line">Sandbox.prototype = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;My Application&#x27;</span>,</span><br><span class="line">  <span class="attr">version</span>: <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>然后在定义默认的初始模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Sandbox.modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Sandbox.modules.dom = <span class="function"><span class="keyword">function</span>(<span class="params">box</span>) </span>&#123;</span><br><span class="line">  box.getElement = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  box.getStyle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  box.foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sandbox.modules.event = <span class="function"><span class="keyword">function</span>(<span class="params">box</span>) </span>&#123;</span><br><span class="line">  box.attachEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  box.detachEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sandbox.modules.ajax = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  box.makeRequest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  box.getResponse = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Sandbox</span>(<span class="params">[<span class="string">&#x27;ajax&#x27;</span>, <span class="string">&#x27;event&#x27;</span>], <span class="keyword">function</span>(box)</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> box.foo); <span class="comment">//undefined  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sandbox(<span class="string">&#x27;ajax&#x27;</span>, <span class="string">&#x27;dom&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">box</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> box.attachEvent) <span class="comment">//undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Sandbox(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">box</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(box); <span class="comment">//所有方法对象</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;看汤姆大叔的博客，记录一下对象创建模式里的沙盒模式&lt;br&gt;沙盒模式即是为一个或多个模块提供单独的上下文环境，而不会影响其他模块的上下文环境，比如有个Sandbox里有3个方法event，dom，ajax，在调用其中2个组成一个环境的话，和调用三个组成的环境完全没有干扰。Sandbox实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sandbox&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; args = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.prototype.slice.call(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//最后一个参数为callback&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    callback = args.pop(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//除最后一个参数外，其他均为要选择的模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    modules = (args[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &amp;amp;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; args[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] === &lt;span class=&quot;string&quot;&gt;&amp;#x27;string&amp;#x27;&lt;/span&gt;) ? args : args[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//强制使用new 操作符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!(&lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Sandbox)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Sandbox(modules, callback);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//添加属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.b = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//向this对象上添加模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//如果没有传模块或者传入的参数为&amp;quot;*&amp;quot;，则认为传入所有模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!modules || modules == &lt;span class=&quot;string&quot;&gt;&amp;#x27;*&amp;#x27;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      modules = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; Sandbox.moduls) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(Sandbox.modules.hasOwnProperty(i)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          modules.push(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//初始化需要的模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;modules.length; i+=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Sandbox.modules[modules[i]](&lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//调用callback&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    callback(&lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//默认添加原型对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sandbox.prototype = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;My Application&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;1.0&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;getName&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="javascript" scheme="http://soonwang.cn/tags/javascript/"/>
    
    <category term="设计模式" scheme="http://soonwang.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://soonwang.cn/2017/02/15/iteration-js/"/>
    <id>http://soonwang.cn/2017/02/15/iteration-js/</id>
    <published>2017-02-15T16:43:34.000Z</published>
    <updated>2021-07-20T02:43:14.064Z</updated>
    
    <content type="html"><![CDATA[<p>记录迭代器模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> agg = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">      data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">      length = data.length;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> element;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">this</span>.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      element = data[index];</span><br><span class="line">      index = index + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">hasNext</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> index &lt; length;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">rewind</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      index = <span class="number">0</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">current</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(agg.hasNext()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(agg.next())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录迭代器模式&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/</summary>
      
    
    
    
    
    <category term="javascript" scheme="http://soonwang.cn/tags/javascript/"/>
    
    <category term="设计模式" scheme="http://soonwang.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>订阅、发布模式</title>
    <link href="http://soonwang.cn/2017/02/10/publish-subscribe/"/>
    <id>http://soonwang.cn/2017/02/10/publish-subscribe/</id>
    <published>2017-02-10T16:02:11.000Z</published>
    <updated>2021-07-20T02:43:14.064Z</updated>
    
    <content type="html"><![CDATA[<p>看汤姆大叔的博客，记录学习下订阅、发布模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Event</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> handlers = [];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.addHandler = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    handlers.push(handler)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.removeHandler = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; handlers.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(handlers[i] == handler) &#123;</span><br><span class="line">        handlers.splice(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.fire = <span class="function"><span class="keyword">function</span>(<span class="params">eventArgs</span>) </span>&#123;</span><br><span class="line">    handlers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">      h(eventArgs);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventAggregator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> events = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getEvent</span>(<span class="params">eventName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> events.filter(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> event.getName() === eventName;</span><br><span class="line">    &#125;)[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.publish = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, eventArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event = getEvent(eventName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!event) &#123;</span><br><span class="line">      event = <span class="keyword">new</span> Event(eventName);</span><br><span class="line">      events.push(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.fire(eventArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event = getEvent(eventName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!event) &#123;</span><br><span class="line">      event = <span class="keyword">new</span> Event(eventName);</span><br><span class="line">      events.push(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.addHandler(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;看汤姆大叔的博客，记录学习下订阅、发布模式&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Event&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; handlers = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.addHandler = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;handler&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    handlers.push(handler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.removeHandler = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;handler&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt; handlers.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(handlers[i] == handler) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        handlers.splice(i, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.fire = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;eventArgs&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    handlers.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;h&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      h(eventArgs);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="javascript" scheme="http://soonwang.cn/tags/javascript/"/>
    
    <category term="设计模式" scheme="http://soonwang.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>记录一些函数</title>
    <link href="http://soonwang.cn/2017/02/09/javascript-some-function/"/>
    <id>http://soonwang.cn/2017/02/09/javascript-some-function/</id>
    <published>2017-02-09T14:22:31.000Z</published>
    <updated>2021-07-20T02:43:14.064Z</updated>
    
    <content type="html"><![CDATA[<h4 id="将-ffffff转化成rgb-255-255-255"><a href="#将-ffffff转化成rgb-255-255-255" class="headerlink" title="将#ffffff转化成rgb(255,255,255)"></a>将#ffffff转化成rgb(255,255,255)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">colorTranslator</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arrColor = str.slice(<span class="number">1</span>).match(<span class="regexp">/\w&#123;2&#125;/g</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;agb(&#x27;</span>+ arrColor.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item, <span class="number">16</span>) || <span class="number">0</span>).join(<span class="string">&#x27;,&#x27;</span>) +<span class="string">&#x27;)&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(colorTranslator(<span class="string">&#x27;#ffffff&#x27;</span>))</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="将’get-element-by-id’转化成驼峰式’getElementById’"><a href="#将’get-element-by-id’转化成驼峰式’getElementById’" class="headerlink" title="将’get-element-by-id’转化成驼峰式’getElementById’"></a>将’get-element-by-id’转化成驼峰式’getElementById’</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;get-element-by-id&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> camel = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  str.split(<span class="string">&#x27;-&#x27;</span>).map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="number">0</span>) &#123;</span><br><span class="line">      newStr += item</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newStr += item.charAt(<span class="number">0</span>).toUpperCase() + item.slice(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(camel(foo))</span><br></pre></td></tr></table></figure><p>Vue里的做法是通过正则表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;get-element-by-id&#x27;</span></span><br><span class="line"><span class="keyword">var</span> camelizeRE = <span class="regexp">/-(\w)/g</span></span><br><span class="line"><span class="keyword">var</span> camelize = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(camelizeRE, <span class="function">(<span class="params">_, c</span>) =&gt;</span> c ? c.toUpperCase() : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(camelize(foo))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;将-ffffff转化成rgb-255-255-255&quot;&gt;&lt;a href=&quot;#将-ffffff转化成rgb-255-255-255&quot; class=&quot;headerlink&quot; title=&quot;将#ffffff转化成rgb(255,255,255)&quot;&gt;&lt;/a&gt;将#ffffff转化成rgb(255,255,255)&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;colorTranslator&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;str&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arrColor = str.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;).match(&lt;span class=&quot;regexp&quot;&gt;/\w&amp;#123;2&amp;#125;/g&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;agb(&amp;#x27;&lt;/span&gt;+ arrColor.map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;parseInt&lt;/span&gt;(item, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;) || &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;).join(&lt;span class=&quot;string&quot;&gt;&amp;#x27;,&amp;#x27;&lt;/span&gt;) +&lt;span class=&quot;string&quot;&gt;&amp;#x27;)&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(colorTranslator(&lt;span class=&quot;string&quot;&gt;&amp;#x27;#ffffff&amp;#x27;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="javascript" scheme="http://soonwang.cn/tags/javascript/"/>
    
  </entry>
  
</feed>
