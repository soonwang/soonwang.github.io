<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BFC</title>
    <url>/2019/09/02/css-bfc/</url>
    <content><![CDATA[<h2 id="BFC-概念"><a href="#BFC-概念" class="headerlink" title="BFC 概念"></a>BFC 概念</h2><p>BFC 即 Block Formatting Contexts（块级格式化上下文），属于普通流定位。具有BFC特性的元素可以看做是隔离了的独立容器，容器里面的元素不会再布局上影响到外面的元素。</p>
<span id="more"></span>

<h2 id="BFC-触发条件"><a href="#BFC-触发条件" class="headerlink" title="BFC 触发条件"></a>BFC 触发条件</h2><ul>
<li>body 根元素</li>
<li>浮动元素：float 值非 none</li>
<li>绝对定位元素：position absolute、fixed</li>
<li>display： inline-block、table-cell、table-caption</li>
<li>overflow 值 非 visible（hidden、auto、scroll）</li>
</ul>
<h2 id="BFC-特性-及-应用"><a href="#BFC-特性-及-应用" class="headerlink" title="BFC 特性 及 应用"></a>BFC 特性 及 应用</h2><ol>
<li>在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。不同 BFC 不会 发生 margin 折叠</li>
<li>在 BFC 中，每一个盒子的左外边缘（margin-left）会接触到 容器的 左边缘（border-left)</li>
<li>可以阻止元素 被 浮动元素 覆盖</li>
<li>清除元素内部浮动</li>
</ol>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 包含块</title>
    <url>/2019/08/30/css-containing-block/</url>
    <content><![CDATA[<h2 id="确定包含块"><a href="#确定包含块" class="headerlink" title="确定包含块"></a>确定包含块</h2><ol>
<li>position 为 static 或 relative，包含块 就是它最近的祖先<strong>块</strong>元素（比如：inline-block, block 或 list-item）或格式化上下文（BFC）的内容区</li>
<li>position 为 absolute，包含块就是它最近的position 不是 static的祖先元素的内容区 + padding区</li>
<li>position fixed，包含块是viewport</li>
</ol>
<span id="more"></span>

<blockquote>
<p>如果 position 是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内容区+padding区</p>
</blockquote>
<ol>
<li>transform | perspective | filter 值不为none</li>
<li>will-change: transform | perspective | filter(filter只在Firefox上生效)</li>
<li>contain: paint (目前仅有chrome新版本支持)</li>
</ol>
<h2 id="根据包含块-计算-百分值"><a href="#根据包含块-计算-百分值" class="headerlink" title="根据包含块 计算 百分值"></a>根据包含块 计算 百分值</h2><ol>
<li>要计算height、top、bottom 的百分值，是相对于包含块的height值。</li>
<li>计算 width、left、right、padding、margin 这些属性由包含块的widt属性值来计算。</li>
</ol>
<h2 id="位置影响-left-right-top-bottom"><a href="#位置影响-left-right-top-bottom" class="headerlink" title="位置影响(left, right, top, bottom)"></a>位置影响(left, right, top, bottom)</h2><ol>
<li>position relative 元素：针对 元素本身的移动，本身元素所占的盒模型位置不变，即不会影响 周围元素的位置</li>
<li>position absolute 元素：针对其包含块的相对位置。比如：left: 0，则 该元素距离 包含块的左侧为0px</li>
</ol>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>搞清楚 eslint 的 plugins 和 extends</title>
    <url>/2022/02/20/eslint-config-extends-vs-plugins/</url>
    <content><![CDATA[<p>最近在鼓捣 eslint 规则配置的时候，有两个配置一直傻傻分不清，这两个配置就是 <code>extends</code> 和 <code>plugins</code>。相信大家在实践过程中也会遇到这样的困扰，今天就来一起看一看，彻底搞清楚。</p>
<p>首先，我们知道 eslint 是一个代码检查工具，它会根据我们在工程里配置的规则，来进行校验。我们常常在以下场景中使用到 eslint。</p>
<ul>
<li>vscode、webstorm 等编辑器、IDE安装插件</li>
<li>工程运行时，通过 eslint-loader 检查及时发现问题</li>
<li>commit 时进行代码检查校验拦截（通常会配合 husky + lint-staged 使用）</li>
</ul>
<p>所以一个团队如果想要保持统一的代码风格、良好的编码习惯，那约定和制定自己的 lint 规则就显得很重要。</p>
<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><p>在简单的场景中，我们可以不需要了解 plugins 和 extends 的概念，比如只是约定「封号」、「引号」的使用：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;semi&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;error&quot;</span><span class="punctuation">,</span> <span class="string">&quot;always&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;quotes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;error&quot;</span><span class="punctuation">,</span> <span class="string">&quot;double&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过这样的配置，就约定了工程里统一强制使用封号结尾和双引号。</p>
<p>然而渐渐的，eslint 默认的一些规则不再满足我们的需要，这时我们就需要引入更多的规则集，这就是 plugins 的概念。</p>
<span id="more"></span>

<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>plugins 可以理解为一个规则集，这些规则能够满足我们的一些特殊场景。比如在 react 工程里，我们需要对 react 代码进行某些特殊的校验，而 eslint 默认的规则已经满足不了我们的需求，这个时候就需要引入能够校验 react 代码的规则，比如 <code>eslint-config-react</code>。<br>引入一个 plugin，通常是两步：</p>
<ol>
<li>安装 plugin，例如 <code>npm i eslint-config-react -D</code></li>
<li>声明 plugin，在工程的配置文件中，比如<code>.eslintrc.json</code>中添加声明配置<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;eslint-config-react&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
plugin 声明即 规则集已经准备好，下一步就是我们要决定在工程里启用哪些规则了，启用规则的方法就是上面所介绍的 rules，需要在 rules 里声明。</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;eslint-config-react&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;react/display-name&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;error&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在定制规则的时候，我们会发现 plugin 里提供了大量的 rules，如果诶个过一遍，决定在工程里应用哪些规则的话，显然会消耗我们大量的精力，而且每个人、每个团队都需要经历一遍，这显然是不合理的。这个时候就轮到我们今天的另一个主角出场了。</p>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>eslint 的 plugin 除了提供规则校验规则外，通常也会提供一些推荐的规则集，比如 <code>eslint-config-react:recommend</code>、<code>eslint-config-react:all</code>。这里的 recommend、all 就是 <code>eslint-config-react</code> 内置的一些规则集合，方便工程里直接使用，方法如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;eslint-config-react:recommend&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样我们就很便利的应用了<code>eslint-config-react</code>插件推荐使用的规则。<br>为了看清 <code>eslint-config-react:recommend</code>具体应用了哪些规则，我们可以直接去看源码：<a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/index.js">https://github.com/yannickcr/eslint-plugin-react/blob/master/index.js</a><br>进入上面链接后，可以看到 <code>recommend</code> 下应用的全部规则如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="string">&#x27;react&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">ecmaFeatures</span>: &#123;</span><br><span class="line">            <span class="attr">jsx</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;react/display-name&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/jsx-key&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/jsx-no-comment-textnodes&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/jsx-no-duplicate-props&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/jsx-no-target-blank&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/jsx-no-undef&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/jsx-uses-react&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/jsx-uses-vars&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/no-children-prop&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/no-danger-with-children&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/no-deprecated&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/no-direct-mutation-state&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/no-find-dom-node&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/no-is-mounted&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/no-render-return-value&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/no-string-refs&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/no-unescaped-entities&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/no-unknown-property&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/no-unsafe&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;react/prop-types&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/react-in-jsx-scope&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;react/require-render-return&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，可以看出这个内容就是一份完整的 eslint 的配置文件。</p>
<p>总结一下，<code>plugins</code> 配置本质上是为了引入更多的校验规则方法，而仅仅引用规则是不会有任何效果的，还需要通过 <code>rules</code> 配置告诉 eslint 需要启用哪些规则。为了更方便的配置<code>plugins</code>和<code>rules</code>，可以配置<code>extends</code>使用 plugin 推荐开启的配置清单。</p>
<p>好了，这次介绍就到这里，如有错误的地方，希望不吝赐教。</p>
]]></content>
      <tags>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>eggjs启动从回车到ready</title>
    <url>/2018/10/27/eggjs-from-enter-to-ready/</url>
    <content><![CDATA[<p>JavaScript代码是单线程运行的，因而一旦有未捕获的异常抛出线程就会挂掉，业务也就不可访问了，所以一般我们在使用koa，express，thinkjs等其他node框架时一般会使用pm2去管理node进程，保证业务的高可用性。而阿里开源的egg框架本身自带的egg-cluster模板已经帮我们做了这个事情，egg的多进程模型和进程间通信官方文档上写的已经很清楚了，今天学习一下源码，希望有所收获。</p>
<h2 id="egg-bin-dev"><a href="#egg-bin-dev" class="headerlink" title="egg-bin dev"></a>egg-bin dev</h2><p>运行一个egg项目，<code>npm run dev</code>在package.json文件里我们发现默认其实执行的是<code>egg-bin dev</code>。egg-bin原来是egg提供的一个开发时使用的命令行工具，翻开egg-bin的代码，我们可以看到egg-bin其实是基于<a href="http://npm.taobao.org/package/common-bin">common-bin</a>开发的，这里不赘述common-bin的用法，感兴趣的童鞋自行去查阅。在<code>lib/cmd/dev.js</code>里我们可以看到<code>egg-bin dev</code>执行的逻辑（去掉debug日志）：</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">* <span class="title function_">run</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> devArgs = <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="title function_">formatArgs</span>(context);</span><br><span class="line">    <span class="keyword">const</span> env = &#123;</span><br><span class="line">      <span class="attr">NODE_ENV</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">      <span class="attr">EGG_MASTER_CLOSE_TIMEOUT</span>: <span class="number">1000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">      <span class="attr">execArgv</span>: context.<span class="property">execArgv</span>,</span><br><span class="line">      <span class="attr">env</span>: <span class="title class_">Object</span>.<span class="title function_">assign</span>(env, context.<span class="property">env</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">helper</span>.<span class="title function_">forkNode</span>(<span class="variable language_">this</span>.<span class="property">serverBin</span>, devArgs, options);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出主要有两步，</p>
<ol>
<li>this.formatArgs(context)，将context上的参数转成自己需要的格式</li>
<li>this.helper.forkNode()，这个是<code>common-bin</code>的语法：</li>
</ol>
<blockquote>
<p>forkNode(modulePath, args, opt) - fork child process, wrap with promise and gracefull exit</p>
</blockquote>
<p>forkNode函数用于fork一个子进程，第一个参数子进程要执行的文件的路径</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">serverBin</span> = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../start-cluster&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>start-cluster</code>文件里主要源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(process.<span class="property">argv</span>[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">require</span>(options.<span class="property">framework</span>).<span class="title function_">startCluster</span>(options);</span><br></pre></td></tr></table></figure>
<p>到此我们知道整个<code>egg-bin dev</code>想要做的事情只有两件：</p>
<ol>
<li>获取参数options，重点是options.framework，即找到要加载的框架</li>
<li>执行require(framework).startCluster()，加载框架并执行startCluster<br>回过头来继续看<code>lib/cmd/dev.js</code>，在<code>formatArgs</code>函数里我们找到获取framework的逻辑：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">&#x27;egg-utils&#x27;</span>);</span><br><span class="line">argv.<span class="property">framework</span> = utils.<span class="title function_">getFrameworkPath</span>(&#123;</span><br><span class="line">    <span class="attr">framework</span>: argv.<span class="property">framework</span>,</span><br><span class="line">    <span class="attr">baseDir</span>: argv.<span class="property">baseDir</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
接下来我们去看下getFrameworkPath的实现逻辑。</li>
</ol>
<h2 id="egg-utils"><a href="#egg-utils" class="headerlink" title="egg-utils"></a>egg-utils</h2><p>在<code>lib/framework.js</code>里我们很容易找到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFrameworkPath</span>(<span class="params">&#123; framework, baseDir &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> pkgPath = path.<span class="title function_">join</span>(baseDir, <span class="string">&#x27;package.json&#x27;</span>);</span><br><span class="line">  <span class="title function_">assert</span>(fs.<span class="title function_">existsSync</span>(pkgPath), <span class="string">`<span class="subst">$&#123;pkgPath&#125;</span> should exist`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> moduleDir = path.<span class="title function_">join</span>(baseDir, <span class="string">&#x27;node_modules&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> pkg = utility.<span class="title function_">readJSONSync</span>(pkgPath);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. pass framework or customEgg</span></span><br><span class="line">  <span class="keyword">if</span> (framework) &#123;</span><br><span class="line">    <span class="comment">// 1.1 framework is an absolute path</span></span><br><span class="line">    <span class="comment">// framework: path.join(baseDir, &#x27;node_modules/$&#123;frameworkName&#125;&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="title function_">isAbsolute</span>(framework)) &#123;</span><br><span class="line">      <span class="keyword">return</span> framework;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.2 framework is a npm package that required by application</span></span><br><span class="line">    <span class="comment">// framework: &#x27;frameworkName&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">assertAndReturn</span>(framework, moduleDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. framework is not specified</span></span><br><span class="line">  <span class="comment">// 2.1 use framework name from pkg.egg.framework</span></span><br><span class="line">  <span class="keyword">if</span> (pkg.<span class="property">egg</span> &amp;&amp; pkg.<span class="property">egg</span>.<span class="property">framework</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">assertAndReturn</span>(pkg.<span class="property">egg</span>.<span class="property">framework</span>, moduleDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2 use egg by default</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">assertAndReturn</span>(<span class="string">&#x27;egg&#x27;</span>, moduleDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码详细讲述了获取framework的逻辑：</p>
<ol>
<li>首先看<code>npm run dev</code>执行时是否指定framework，有的话继续判断是否是绝对路劲，转为合适的格式返回</li>
<li>尝试读取package.json，查看是否有egg以及egg的framework配置</li>
<li>默认返回<code>egg</code></li>
</ol>
<p>这里我们看默认egg的情况，则forkNode执行的语句为<code>require(&#39;egg&#39;).startCluster(options)</code></p>
<h2 id="require-‘egg’-startCluster-options"><a href="#require-‘egg’-startCluster-options" class="headerlink" title="require(‘egg’).startCluster(options)"></a>require(‘egg’).startCluster(options)</h2><p>在egg的<code>index.js</code>文件的开头我们看到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start egg application with cluster mode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">startCluster</span> = <span class="built_in">require</span>(<span class="string">&#x27;egg-cluster&#x27;</span>).<span class="property">startCluster</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很好，终于看到<code>egg-cluster</code>了。</p>
<h2 id="egg-cluster"><a href="#egg-cluster" class="headerlink" title="egg-cluster"></a>egg-cluster</h2><p>首先是<code>index.js</code>中暴露的startCluster方法，也是整个egg-cluster的入口方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">startCluster</span> = <span class="keyword">function</span>(<span class="params">options, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Master</span>(options).<span class="title function_">ready</span>(callback);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，egg-cluster是一个Master实例，Master就显得至关重要了。<br>介绍master之前先梳理一下egg-cluster的目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">egg-cluster</span><br><span class="line">├── lib</span><br><span class="line">│   ├── utils</span><br><span class="line">│   │    ├── manager.js</span><br><span class="line">│   │    ├── messenger.js</span><br><span class="line">│   │    ├── options.js</span><br><span class="line">│   │    └── terminate.js</span><br><span class="line">│   ├── agent_worker.js</span><br><span class="line">│   ├── app_worker.js</span><br><span class="line">│   └── master.js</span><br><span class="line">├── index.js</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>先看master.js，下面截取出Master构造函数的关键代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">options</span> = <span class="title function_">parseOptions</span>(options);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">workerManager</span> = <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">messenger</span> = <span class="keyword">new</span> <span class="title class_">Messenger</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">ready.<span class="title function_">mixin</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ready后的回调函数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">ready</span>(<span class="function">() =&gt;</span> &#123;...&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加监听事件，有agent-exit, agent-start, app-exit, app-start, reload-worker, realport</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">on</span>(<span class="string">&#x27;...&#x27;</span>, <span class="function">() =&gt;</span> &#123;...&#125;)</span><br><span class="line"><span class="comment">// 一次性监听事件，启动appWorkers</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">once</span>(<span class="string">&#x27;agent-start&#x27;</span>, <span class="variable language_">this</span>.<span class="property">forkAppWorkers</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// forkAgentWorker</span></span><br><span class="line"><span class="title function_">detectPort</span>(<span class="function">(<span class="params">err, port</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">forkAgentWorkder</span>();  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听agent、workder异常</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">workerManager</span>.<span class="title function_">on</span>(<span class="string">&#x27;exception&#x27;</span>, <span class="function">()=&gt;</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>
<p>从上往下执行，首先是parseOptions，这个函数是<code>lib/utils/options.js</code>，用来解析并返回正确格式的options</p>
<h3 id="options-js"><a href="#options-js" class="headerlink" title="options.js"></a>options.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaults = &#123;</span><br><span class="line">        <span class="attr">framework</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">baseDir</span>: process.<span class="title function_">cwd</span>(),</span><br><span class="line">        <span class="attr">port</span>: options.<span class="property">https</span> ? <span class="number">8443</span> : <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">workers</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">plugins</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">https</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    options = <span class="title function_">extend</span>(defaults, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码片段仅截取部分，显示options的各个属性，和egg-bin dev提供的基本一致。具体的略过不讲。<br>接下来是new Manager();</p>
<h3 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h3><p>将manager.js里的属性和方法简单画成UML图形如下：</p>
<p><img data-src="https://kaola-haitao.oss.kaolacdn.com/769ea022-22ba-4861-80c6-ebf837f6e429_176_315.svg" alt="image"></p>
<p>Manager主要是用于管理agent和worker，有两个方法比较特殊，分别是count()和startCheck()，count()返回agent和worker的数量，而startCheck()每10秒执行一次，判断count返回的agent和worker数量是否大于0，出现3次异常，则发出exception事件，并不再执行。</p>
<h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p>将messenger.js里的属性和方法简单画成UML图如下：</p>
<p><img data-src="https://kaola-haitao.oss.kaolacdn.com/8347fbea-a656-4971-ab24-9eb8a43e05cb_189_143.svg" alt="image"></p>
<p>Messenger类</p>
<ul>
<li>send: 做了一些from和to的处理工作，并根据from和to，调用其他四个方法。</li>
<li>sendToMaster: 使用的是this.master.emit方法，Master本身就是继承于EventEmitter，直接调用emit方法，使用master.on既可以监听到。</li>
<li>sendToParent: 调用的是process.send()</li>
</ul>
<blockquote>
<p>If Node.js is spawned with an IPC channel, the process.send() method can be used to send messages to the parent process. Messages will be received as a ‘message’ event on the parent’s ChildProcess object.</p>
</blockquote>
<ul>
<li>sendToAppWorker: 调用的是<a href="https://npm.taobao.org/package/sendmessage">sendmessage</a>(worker, data);</li>
<li>sendToAgentWorker: 调用的是sendmessage(agentWorker, data);</li>
</ul>
<blockquote>
<p>sendmessage(childprocess, message): Send a cross process message. If a process is not child process, this will just call process.emit(‘message’, message) instead.</p>
</blockquote>
<h3 id="terminate-js"><a href="#terminate-js" class="headerlink" title="terminate.js"></a>terminate.js</h3><p>terminate.js文件主要用于终止进程，这里不再赘述。</p>
<h3 id="启动agentWorker，agent-worker-js"><a href="#启动agentWorker，agent-worker-js" class="headerlink" title="启动agentWorker，agent_worker.js"></a>启动agentWorker，agent_worker.js</h3><p>回到Master的构造函数中，从之前整理出的代码片段来看，实例化manager，messenger之后，注册ready的回调函数，接下来就是启动agent进程了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">forkAgentWorker</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> agentWorker = child_process.<span class="title function_">fork</span>(<span class="string">&#x27;lib/agent_worker.js&#x27;</span>, args, opt);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">workerManager</span>.<span class="title function_">setAgent</span>(agentWorker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面片段仅截取关键部分。可以看出使用了node的原生模块<code>child_process</code>的fork方法。下面继续看<code>agent_worker.js</code>;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Agent</span> = <span class="built_in">require</span>(options.<span class="property">framework</span>).<span class="property">Agent</span>;</span><br><span class="line"><span class="keyword">const</span> agent = <span class="keyword">new</span> <span class="title class_">Agent</span>(options);</span><br><span class="line"></span><br><span class="line">agent.<span class="title function_">ready</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// don&#x27;t send started message to master when start error</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  agent.<span class="title function_">removeListener</span>(<span class="string">&#x27;error&#x27;</span>, startErrorHandler);</span><br><span class="line">  process.<span class="title function_">send</span>(&#123; <span class="attr">action</span>: <span class="string">&#x27;agent-start&#x27;</span>, <span class="attr">to</span>: <span class="string">&#x27;master&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从上面可以看到agentWorker实例了framework的Agent，而根据之前的分析，framework默认情况下是egg，这里为了简化分析，将framework认为是egg，那可以认为这个子进程执行了new Agent(options)操作；并且在ready回调中向master进程发送<code>agent-start</code>消息。而发送的这个消息则至关重要，master进程中对于它的监听回调函数中执行了worker进程的fork。</p>
<h3 id="启动appWorker，app-worker-js"><a href="#启动appWorker，app-worker-js" class="headerlink" title="启动appWorker，app_worker.js"></a>启动appWorker，app_worker.js</h3><p>仍然回到Master的构造函数那里，可以看到</p>
<blockquote>
<p>this.once(‘agent-start’, this.forkAppWorkers.bind(this));</p>
</blockquote>
<p>当agentWorker进程启动ready后，发送agent-start消息给master进程，master进程第一次收到后执行forkAppWorkers();</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">forkAppWorkers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">cfork</span>(&#123;</span><br><span class="line">      <span class="attr">exec</span>: <span class="variable language_">this</span>.<span class="title function_">getAppWorkerFile</span>(),</span><br><span class="line">      args,</span><br><span class="line">      <span class="attr">silent</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">workers</span>,</span><br><span class="line">      <span class="comment">// don&#x27;t refork in local env</span></span><br><span class="line">      <span class="attr">refork</span>: <span class="variable language_">this</span>.<span class="property">isProduction</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    cluster.<span class="title function_">on</span>(<span class="string">&#x27;fork&#x27;</span>, <span class="function"><span class="params">worker</span> =&gt;</span> &#123;...&#125;);</span><br><span class="line">    cluster.<span class="title function_">on</span>(<span class="string">&#x27;listening&#x27;</span>, <span class="function">(<span class="params">worker, address</span>) =&gt;</span> &#123;...&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://npm.taobao.org/package/cfork">cfork</a> npm包，使用原生cluster的setupMaster方法和fork方法。对cfork感兴趣的童鞋可以去<a href="https://163.lu/k/htryK3">看</a></p>
<blockquote>
<p>cluster fork and restart easy way</p>
</blockquote>
<p>我们接着看简化版的app_worker.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Application</span> = <span class="built_in">require</span>(options.<span class="property">framework</span>).<span class="property">Application</span>;</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Application</span>(options);</span><br><span class="line">process.<span class="title function_">send</span>(&#123; <span class="attr">to</span>: <span class="string">&#x27;master&#x27;</span>, <span class="attr">action</span>: <span class="string">&#x27;realport&#x27;</span>, <span class="attr">data</span>: port &#125;);</span><br><span class="line">app.<span class="title function_">ready</span>(startServer);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">startServer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    server.<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).<span class="title function_">createServer</span>(app.<span class="title function_">callback</span>());</span><br><span class="line">    server.<span class="title function_">listen</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以知道，app_worker中执行了new Application()，并使用原生http（或https）模块启动一个server。当server执行listen方法时，触发了master中 forkAppWorkers方法中注册的listening回调事件</p>
<blockquote>
<p>cluster.on(‘listening’, (worker, address) &#x3D;&gt; {…});</p>
</blockquote>
<p>该回调事件中向maste发送了<code>app-start</code>事件。<br><code>app-start</code>的回调函数中在最后执行了</p>
<blockquote>
<p>this.ready(true);（这里使用了<a href="http://npm.hz.netease.com/package/get-ready">get-ready</a>， 构造函数中通过<code>ready.mixin(this);</code>，注入ready方法，并添加回调函数）</p>
</blockquote>
<p>这一句会触发master构造函数中注册的ready回调函数。该回调函数中将isStarted设置成true， 并想parent，app，agent发送<code>egg-ready</code>事件。</p>
<p>到这里启动就基本完成了。<br>启动的时序正如官方文档所描述的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------+           +---------+          +---------+</span><br><span class="line">|  Master |           |  Agent  |          |  Worker |</span><br><span class="line">+---------+           +----+----+          +----+----+</span><br><span class="line">     |      fork agent     |                    |</span><br><span class="line">     +--------------------&gt;|                    |</span><br><span class="line">     |      agent ready    |                    |</span><br><span class="line">     |&lt;--------------------+                    |</span><br><span class="line">     |                     |     fork worker    |</span><br><span class="line">     +-----------------------------------------&gt;|</span><br><span class="line">     |     worker ready    |                    |</span><br><span class="line">     |&lt;-----------------------------------------+</span><br><span class="line">     |      Egg ready      |                    |</span><br><span class="line">     +--------------------&gt;|                    |</span><br><span class="line">     |      Egg ready      |                    |</span><br><span class="line">     +-----------------------------------------&gt;|</span><br></pre></td></tr></table></figure>

<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>本文只是简单的从源码角度大致梳理了egg启动过程中的做的一些事情，很多东西还需要进一步深入研究，比如<code>agent_worker.js</code>使用的是<code>child_process</code>的fork方法，而<code>app_worker.js</code>使用的是cfork（使用的是原生的cluster的fork），需要研究下child_process和cluster。此外，本文还没涉及到Agent和Application的具体的实现，Agent和Application都是基于EggApplication，而EggApplication是基于EggCore的，EggCore继承于Koa。等等。</p>
]]></content>
      <tags>
        <tag>eggjs</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2017/02/15/iteration-js/</url>
    <content><![CDATA[<p>记录迭代器模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> agg = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">      data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">      length = data.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> element;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      element = data[index];</span><br><span class="line">      index = index + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">hasNext</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> index &lt; length;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">rewind</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      index = <span class="number">0</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">current</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(agg.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(agg.<span class="title function_">next</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一些函数</title>
    <url>/2017/02/09/javascript-some-function/</url>
    <content><![CDATA[<h4 id="将-ffffff转化成rgb-255-255-255"><a href="#将-ffffff转化成rgb-255-255-255" class="headerlink" title="将#ffffff转化成rgb(255,255,255)"></a>将#ffffff转化成rgb(255,255,255)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">colorTranslator</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> arrColor = str.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">match</span>(<span class="regexp">/\w&#123;2&#125;/g</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;agb(&#x27;</span>+ arrColor.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item, <span class="number">16</span>) || <span class="number">0</span>).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) +<span class="string">&#x27;)&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">colorTranslator</span>(<span class="string">&#x27;#ffffff&#x27;</span>))</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h4 id="将’get-element-by-id’转化成驼峰式’getElementById’"><a href="#将’get-element-by-id’转化成驼峰式’getElementById’" class="headerlink" title="将’get-element-by-id’转化成驼峰式’getElementById’"></a>将’get-element-by-id’转化成驼峰式’getElementById’</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;get-element-by-id&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> camel = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> newStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  str.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="number">0</span>) &#123;</span><br><span class="line">      newStr += item</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newStr += item.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + item.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">camel</span>(foo))</span><br></pre></td></tr></table></figure>
<p>Vue里的做法是通过正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;get-element-by-id&#x27;</span></span><br><span class="line"><span class="keyword">var</span> camelizeRE = <span class="regexp">/-(\w)/g</span></span><br><span class="line"><span class="keyword">var</span> camelize = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">replace</span>(camelizeRE, <span class="function">(<span class="params">_, c</span>) =&gt;</span> c ? c.<span class="title function_">toUpperCase</span>() : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">camelize</span>(foo))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>kali2安装vnc server记录</title>
    <url>/2018/01/12/kali-install-vncsever/</url>
    <content><![CDATA[<p>在kali2上安装vnc server的过程中遇到一些问题，记录总结下</p>
<ul>
<li>安装vnc server，选择vnc4server，执行命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vnc4server</span><br></pre></td></tr></table></figure></li>
<li>首次启动vncserver 执行命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vncserver</span><br></pre></td></tr></table></figure></li>
<li>首次启动，需要输入密码和验证密码，以及一个是否设置【只读】密码，会保存在~&#x2F;.vnc&#x2F;passwd中</li>
<li>启动时，往往会报错，此时在~&#x2F;.vnc&#x2F;中查看是否有xstartup文件，没有新增一个，默认可以写入<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> ~/.vnc/xstartup </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">xterm &amp;</span><br></pre></td></tr></table></figure></li>
<li>在vnc viewer中连接vnc server，ip+桌面号或者端口号，</li>
</ul>
<span id="more"></span>

<h2 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h2><h3 id="vnc-viewer连接问题"><a href="#vnc-viewer连接问题" class="headerlink" title="vnc viewer连接问题"></a>vnc viewer连接问题</h3><p>此时一般会有两种异常情况</p>
<ol>
<li>一种是timeout，等待很长时间，然后提示超时，这种情况要检查网络，vnc server所在主机是否开放相应的端口（linux可以使用ufw管理软件）；</li>
<li>另一种异常是refused，可以尝试使用<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet &#123;ip&#125; &#123;port&#125;</span><br></pre></td></tr></table></figure>
远程测试vnc server所在主机是否refused，如果refused，ssh远程登录到该主机，使用<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 127.0.0.1 &#123;port&#125;</span><br></pre></td></tr></table></figure>
测试，会发现此时是可以连接的。这种异常需要在vncserver启动时加上<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-localhost no</span><br></pre></td></tr></table></figure>
参数即可</li>
</ol>
<h3 id="vnc-viewer连接之后的显示问题"><a href="#vnc-viewer连接之后的显示问题" class="headerlink" title="vnc viewer连接之后的显示问题"></a>vnc viewer连接之后的显示问题</h3><p>若使用上面提供的xstartup代码，连接之后会发现只有个终端，这个效果肯定不是我们希望的，甚至还不如直接ssh登录呢！所以，要搞出桌面。</p>
<ul>
<li>安装桌面<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gnome-core xfce4</span><br></pre></td></tr></table></figure></li>
<li>配置~&#x2F;.vnc&#x2F;xstartup文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">unset</span> SESSION_MANAGER</span><br><span class="line"><span class="built_in">unset</span> DBUS_SESSION_BUS_ADDRESS</span><br><span class="line">startxfce4 &amp;</span><br><span class="line">[ -x /etc/vnc/xstartup ] &amp;&amp; <span class="built_in">exec</span> /etc/vnc/xstartup</span><br><span class="line">[ -r <span class="variable">$HOME</span>/.Xresources ] &amp;&amp; xrdb <span class="variable">$HOME</span>/.Xresources</span><br><span class="line">xsetroot -solid grey</span><br><span class="line">vncconfig -iconic &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>重启vncserver，关闭vncsever命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vncserver -<span class="built_in">kill</span> :number</span><br></pre></td></tr></table></figure>
其中number表示桌面号，<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vncserver -localhost no</span><br></pre></td></tr></table></figure>
启动。</li>
</ul>
<h3 id="vnc-server启动失败问题"><a href="#vnc-server启动失败问题" class="headerlink" title="vnc server启动失败问题"></a>vnc server启动失败问题</h3><p>在执行一个vncserver关闭命令之后，可能下次启动会提示失败，查看日志，提示类似</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fatal server error:</span><br><span class="line">(EE) Cannot establish any listening sockets - Make sure an X server isn<span class="string">&#x27;t already running(EE)</span></span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /tmp/.X11-unit/</span><br></pre></td></tr></table></figure>
<p>接着</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -C Xorg</span><br></pre></td></tr></table></figure>
<p>kill掉显示的进程即可。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="vnc-viewer连接的窗口大小、分辨率"><a href="#vnc-viewer连接的窗口大小、分辨率" class="headerlink" title="vnc viewer连接的窗口大小、分辨率"></a>vnc viewer连接的窗口大小、分辨率</h3><p>在vnc server 启动时加上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-geometry 1366x768</span><br></pre></td></tr></table></figure>
<p>类似参数</p>
]]></content>
      <tags>
        <tag>kali</tag>
        <tag>vnc server</tag>
      </tags>
  </entry>
  <entry>
    <title>monorepo commit 加速【第二弹】</title>
    <url>/2022/09/04/monorepo-commit-speed-up/</url>
    <content><![CDATA[<p>随着业务的发展，monorepo 工程越来越大~</p>
<ul>
<li>在 <code>git commit</code> 时耗时会比较久，耗时是大概 1min+；</li>
<li>在 <code>git merge release</code> 分支时耗时会更久，常常是 5min+;<br>所以在实际开发过程中，会发现有部分同学偶尔会跳过 git hook，跳过 lint 校验拦截，提交有类型报错的代码。</li>
</ul>
<h2 id="为什么会这么慢？"><a href="#为什么会这么慢？" class="headerlink" title="为什么会这么慢？"></a>为什么会这么慢？</h2><p>根据以往的工作经验，在没有用 ts 的工程里 lint 执行都是比较快的，所以这里猜想是 ts 的某些 rule 影响了整体的执行速度，终于在 typescript-eslint 找到了原因：<a href="https://typescript-eslint.io/docs/linting/troubleshooting/#my-linting-feels-really-slow">Troubleshooting &amp; FAQs | TypeScript ESLint</a><br><img data-src="/images/monorepo-commit-speed-up/feeling-slow.png" alt="图片"><br><img data-src="/images/monorepo-commit-speed-up/how-is-perform.png" alt="图片"><br>如果我们在工程里开启了type-aware lint，那么执行 lint 的时间将会和构建时间一样长。<br>typescript-eslint  的一些 rules 是依赖 type information，所以在执行 lint 前会先编译一遍ts<br><a href="https://typescript-eslint.io/docs/linting/typed-linting/">Linting with Type Information | TypeScript ESLint</a> 官网这里具体描述了type-aware 是如何开启的：<br><img data-src="/images/monorepo-commit-speed-up/lint-with-type.png" alt="图片"></p>
<ol>
<li>配置 <code>parserOptions</code>（tsconfigRoot、project）</li>
<li>配置 <code>type-aware</code> 相关 rules</li>
</ol>
<span id="more"></span>

<h2 id="以前的优化"><a href="#以前的优化" class="headerlink" title="以前的优化"></a>以前的优化</h2><p>在之前也曾做过一次 commit lint 优化，当时的判断是 ts 类型信息校验是有必要的，贸然去掉 type 相关校验可能会有隐患。所以当时的思路是如何缩小编译范围。<br>默认在执行 lint 时，会构建整个 monorepo 的 ts 类型信息，项目越大，耗时会越久。<br>在这次优化里，是修改每个子项目里的 .eslintrc.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">      <span class="attr">tsconfigRootDir</span>: __dirname,</span><br><span class="line">      <span class="attr">project</span>: [<span class="string">&#x27;./tsconfig.json&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增了上面列出的两项配置：root、parserOptions，把需要构建生成 ts 类型的文件范围缩小到当前子目录。在实际测试中：</p>
<ul>
<li>配置前，提交一个 ts 文件耗时 1min 1s</li>
<li>配置后，提交一个 ts 文件耗时 25s<br>基本是符合预期的，但是总体速度还是很慢，优化不明显，而且还带来额外的问题<br>带来的问题<br>由于缩小了构建生成 TS 类型的文件范围，所以当 features&#x2F;common 和 features&#x2F;pc 目录下文件类型有变化，而apps&#x2F;clm 中未对应修改时，在 commit 时 lint 会忽略，不会拦截成功，存在一定风险。</li>
</ul>
<h2 id="新方案尝试"><a href="#新方案尝试" class="headerlink" title="新方案尝试"></a>新方案尝试</h2><p>本次优化的目标：加快本地提交的速度，同时不能牺牲代码质量<br>为了加快本地 commit 速度，需要把耗时最久的 type-aware 相关的 rules 在 husky 时忽略，然后在 CI 时校验所有 rules，并及时通知校验结果。为了保证最终合代码时的质量，开启 MR 校验拦截。<br>大致思路如下：<br><img data-src="/images/monorepo-commit-speed-up/monorepo-commit-speed.excalidraw.png" alt="图片"></p>
<h3 id="1-配置-lint-staged-时关闭-type-aware-rules"><a href="#1-配置-lint-staged-时关闭-type-aware-rules" class="headerlink" title="1. 配置 lint-staged 时关闭 type-aware rules"></a>1. 配置 lint-staged 时关闭 type-aware rules</h3><p>package.json: </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;lint-staged&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;*.&#123;ts,tsx&#125;&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;node --max_old_space_size=16384 ./node_modules/eslint/bin/eslint.js --fix --color --cache --quiet --no-eslintrc --config .husky.eslintrc.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;git add&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/monorepo-commit-speed-up/eslintrc-config.png" alt="图片"><br><a href="https://eslint.org/docs/latest/user-guide/command-line-interface#-c---config">https://eslint.org/docs/latest/user-guide/command-line-interface#-c---config</a><br>通过配置lint-staged命令，给 eslint 指定单独的配置文件，即.husky.eslintrc.js :</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&quot;@byted-clm&quot;</span>],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">tsconfigRootDir</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">project</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/await-thenable&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-floating-promises&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-for-in-array&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-implied-eval&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-misused-promises&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-unnecessary-type-assertion&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-unsafe-argument&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-unsafe-assignment&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-unsafe-call&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-unsafe-member-access&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-unsafe-return&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/require-await&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/restrict-plus-operands&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/restrict-template-expressions&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/unbound-method&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">ignorePatterns</span>: [<span class="string">&#x27;xxx&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭 type-aware 校验需要同时满足两个条件：</p>
<ol>
<li>parserOptions.project: null，tsconfigRootDir: null</li>
<li>关闭<a href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/src/configs/recommended-requiring-type-checking.ts">相关 rules</a></li>
</ol>
<h3 id="2-配置-CI"><a href="#2-配置-CI" class="headerlink" title="2. 配置 CI"></a>2. 配置 CI</h3><p>在实际运行中，遇到了几个问题：</p>
<ul>
<li>lint 执行时，node 默认分配内存不够，在 pipeline 运行时会报错</li>
<li>eslint 执行耗时 15min+，意味着 MR 时可能会卡很久……<br>下面分别说一下我的解决思路，也欢迎大家一起探讨。</li>
</ul>
<h4 id="a-Lint-内存不够"><a href="#a-Lint-内存不够" class="headerlink" title="a. Lint 内存不够"></a>a. Lint 内存不够</h4><p>这个问题比较容易解决，重新分配更大内存即可。<br>package.json 中 新增 ci:lint 执行脚本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;ci:lint&quot;</span>: <span class="string">&quot;node --max_old_space_size=16384 ./node_modules/eslint/bin/eslint.js  --ext .ts,.tsx --fix --color --cache --quiet ./&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b-Pipeline-耗时长"><a href="#b-Pipeline-耗时长" class="headerlink" title="b. Pipeline 耗时长"></a>b. Pipeline 耗时长</h4><p>Pipeline 耗时长有两处可优化点：</p>
<ol>
<li>pnpm i 安装依赖耗时；</li>
<li>eslint 执行时间较长；</li>
</ol>
<p>上面两个优化点均可通过缓存来解决，分别缓存 node_modules 和 .eslintcache</p>
<p>在第一次运行 pipeline 时，发现 eslint 执行耗时非常久，整体 pipeline 执行完成需要 15min ~ 20min。</p>
<p>可以想到，在 MR 的节点，因为 lint 需要卡这么长时间，也是很痛苦的。<br>那为什么在 pipeline 中执行 eslint 需要这么久呢？而本地执行 lint 的时候并不需要这么长时间的。<br>其中的奥妙依然是缓存！在本地工程运行时，可以看到根目录下生成了一个 .eslintcache 文件，而这个文件是我们在执行 lint 的时候加上 –cache 的效果：</p>
<p>在 pipeline 执行时，工程是从 git clone 的，而 .eslintcache 文件是 gitignore 的。<br>那为了给 eslint 加速，我们需要在 ci 里缓存 .eslintcache 文件。<br>这里大家可以再思考下，既然 .eslintcache 缓存可以加快速度，那 ts 的编译是否可以利用缓存加速 type 信息的生成呢？</p>
<blockquote>
<p>eslint cache 还有一个细节点：在 pipeline 中执行 eslint 时，还需要设置 –cache-strategy content<br><img data-src="/images/monorepo-commit-speed-up/eslint-cache-strategy.png" alt="图片"></p>
</blockquote>
<p>设置缓存策略后 pipeline 执行时间锐减：5-6min</p>
<table>
<thead>
<tr>
<th>优化前</th>
<th>优化后</th>
</tr>
</thead>
<tbody><tr>
<td>- git commit:  1min+；</td>
<td>- local git commit:  10s 左右；</td>
</tr>
<tr>
<td>- git merge release 分支： 5min+；</td>
<td>- ci lint命中缓存时：4min-6min左右；</td>
</tr>
<tr>
<td>-</td>
<td>- ci lint 未命中缓存时：15-20min；</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>eslint</tag>
        <tag>monorepo</tag>
        <tag>husky</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 monorepo 工程 husky 提交慢的问题</title>
    <url>/2022/03/06/monorepo-tslint-slow-fix/</url>
    <content><![CDATA[<p>业务发展了一年多，随着工程越来越大，发现在提交代码的时候，耗时会很久。最近在业务需求不是很紧的时候，就抽空研究了一下。</p>
<p>在提交代码的时候，触发了 husky 配置的 <code>pre-commit</code>的 git hooks。相信大家对于这个 git hook 不会很陌生，我们大部分需要团队合作的项目，为了约束大家的代码规范，通常会选择使用 husky 并且在提交前进行代码校验拦截，这个时机就刚好是 <code>pre-commit</code> git hooks 的时机。</p>
<p>所以问题一下就变得清晰起来，是 pre-commit 的 hook 执行的 lint 检查耗时过长。首先先介绍下我们工程的技术选型：yarn + learn + ts + react ，在正式排查前，猜测主要导致 lint 执行慢的因素大概有两个 monorepo（工程多、代码量大）、ts（ts 类型检查耗时）。</p>
<p>在开始排查问题之前，先做了个小测试：只改动了一个 tsx 文件，并尝试提交，计时发现，从开始 commit 到 commit 完成，发现竟然耗时了 1min+，晕~。这里就猜想会不会是某个 lint 规则 或 某个 lint 插件导致运行很慢的？接下来就沿着这个思路进行排查。 </p>
<span id="more"></span>

<p>由于工程里使用 lint 规则是继承公司的统一 lint 规则配置，而在打开 node_modules 里这份统一的规则集时，人傻了，一大堆的规则，浩如烟海，（他们大概是把每一条规则都自己定制了一遍吧~）。之后更加坚定了之前的想法：规则太多、插件太多，有可能是由于某几个规则或者插件拉低了整个 lint 的速度。</p>
<p>第一步是修改 .tslintrc.json，将文件里配置的工程规则去掉，然后添加上 eslint、react、tslint recommend 以及 airbnb 的 lint 规则。配置完成完成后，重新提交一个文件，发现速度很快，基本上是秒提交…… 这再次验证了之前的猜想：公司统一的lint规则中存在某些规则或者lint插件拖累了整个lint 的运行速度，而且由于一个文件的lint执行耗时 1min+，很可能是由于执行了 ts 编译，为了检测 ts 的类型这样。</p>
<p>带着这样的疑问，打开了 typescript-eslint 的官网，果然在这里找到了答案</p>
<p><a href="https://typescript-eslint.io/docs/linting/type-linting#how-is-performance">Linting with Type Information | TypeScript ESLint</a></p>
<p>原文如下：</p>
<blockquote>
<p>Well (for full disclosure) there is a catch; by including <code>parserOptions.project</code> in your config, you are essentially asking TypeScript to do a build of your project before ESLint can do its linting. For small projects this takes a negligible amount of time (a few seconds); for large projects, it can take longer (30s or more).</p>
</blockquote>
<blockquote>
<p>Most of our users are fine with this, as they think the power of type-aware static analysis is worth it. Additionally, most users primarily consume lint errors via IDE plugins which, through some caching magic, do not suffer the same penalties. This means that generally they usually only run a complete lint before a push, or via their CI, where the extra time really doesn’t matter.</p>
</blockquote>
<blockquote>
<p><strong>We strongly recommend you do use type-aware linting</strong>, but the above information is included so that you can make your own, informed decision.</p>
</blockquote>
<p>通过这篇文章，可以知道由于使用了「@typescript-eslint&#x2F;recommended-requiring-type-checking」插件，会执行在执行 lint 前，为了校验 ts 的类型是否正确，从而去编译工程，而校验的范围由这么几个配置决定：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">   <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">+  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">+    <span class="attr">tsconfigRootDir</span>: __dirname,</span><br><span class="line">+    <span class="attr">project</span>: [<span class="string">&#x27;./tsconfig.json&#x27;</span>],</span><br><span class="line">+  &#125;,</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>其中，parserOptions.tsconfigRootDir 告诉解析器项目根目录绝对路径，从而保证不会超过这个范围。parserOptions.project 告诉解析器配置文件 tsconfig.json 的相对路劲。</p>
<p>了解了这个规则之后，再回到我们的之前的初衷上来：我们想要提高 lint 的运行速度。那么自然我们面临几个选择：</p>
<ol>
<li>去掉 type checking，不检查 ts 类型，这样就会免去 ts 的编译过程，速度极大提升</li>
<li>控制 type checking 的范围，当前工程的配置是会编译 monorepo 的所有项目，那如果配置成每个子项目只 check 到自己的根目录下，对于我们多个子项目的 monorepo 来说，速度也会有明显提升（PS：这里还需要注意，如果各个子项目互相有依赖的话，这种配置可能导致修改了一个子项目的类型，一个子项目的 tslint 并不会校验出来……）</li>
</ol>
<p>第一种方案直接去掉类型校验，对于我们多人协作的项目来说不太可取，类型的校验还是比较重要的。所以我们选择了第二种！</p>
<p>其实，还有一种思路是 husky 拦截时不做 type check，可以结合 gitlab 的 pipeline 去做相关校验的事情。这种方案的问题是校验之后了，开发者提交了之后再发现问题，去改的动力可能就没有那么强了~</p>
]]></content>
      <tags>
        <tag>eslint</tag>
        <tag>monorepo</tag>
        <tag>husky</tag>
      </tags>
  </entry>
  <entry>
    <title>订阅、发布模式</title>
    <url>/2017/02/10/publish-subscribe/</url>
    <content><![CDATA[<p>看汤姆大叔的博客，记录学习下订阅、发布模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Event</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> handlers = [];</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">addHandler</span> = <span class="keyword">function</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">    handlers.<span class="title function_">push</span>(handler)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">removeHandler</span> = <span class="keyword">function</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; handlers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(handlers[i] == handler) &#123;</span><br><span class="line">        handlers.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">fire</span> = <span class="keyword">function</span>(<span class="params">eventArgs</span>) &#123;</span><br><span class="line">    handlers.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">h</span>) &#123;</span><br><span class="line">      <span class="title function_">h</span>(eventArgs);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">EventAggregator</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> events = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getEvent</span>(<span class="params">eventName</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> events.<span class="title function_">filter</span>(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> event.<span class="title function_">getName</span>() === eventName;</span><br><span class="line">    &#125;)[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">publish</span> = <span class="keyword">function</span>(<span class="params">eventName, eventArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> event = <span class="title function_">getEvent</span>(eventName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!event) &#123;</span><br><span class="line">      event = <span class="keyword">new</span> <span class="title class_">Event</span>(eventName);</span><br><span class="line">      events.<span class="title function_">push</span>(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.<span class="title function_">fire</span>(eventArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">subscribe</span> = <span class="keyword">function</span>(<span class="params">eventName, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> event = <span class="title function_">getEvent</span>(eventName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!event) &#123;</span><br><span class="line">      event = <span class="keyword">new</span> <span class="title class_">Event</span>(eventName);</span><br><span class="line">      events.<span class="title function_">push</span>(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.<span class="title function_">addHandler</span>(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>styled-components 使用 loadable 懒加载时样式优先级问题</title>
    <url>/2022/02/13/react-styled-components-and-loadable/</url>
    <content><![CDATA[<p>最近在 React 项目中引入 <code>@loadable/component</code> 进行懒加载优化时，发现了一个样式优先级问题。<br>我们工程里使用的是公司内部组件库，在想要覆盖组件库组件的样式时，基于 <code>styled-components</code> 的写法如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖 Button 组件样式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CustomButton</span> = <span class="title function_">styled</span>(<span class="title class_">Button</span>)<span class="string">`</span></span><br><span class="line"><span class="string">    width: 80px;</span></span><br><span class="line"><span class="string">    height: 32px;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p>正常情况下，上述代码应该会生效，即最终展现在页面上的按钮样式宽度应该是 80 px，高度为 32 px，覆盖原 Button 组件的宽高样式。</p>
<p>但是在实际使用过程中，我们发现了一些异常：覆盖的样式会偶现失效的情况。有些时候自定义宽高会生效，有些时候自定义宽高不会生效。经过排查，发现如果是在<code>CustomButton</code>所在页面刷新，则按钮展示的宽高是符合预期的，如果是从其他页面进入的，则自定义宽高不会生效。没有生效的原因也很简单，<code>CustomButton</code> 的样式优先级排在了 <code>Button</code> 后面。</p>
<span id="more"></span>

<p>带着这样的问题我们去了解 <code>styled-components</code> 的机制。在默认情况下，<code>styled-components</code>会在 <code>&lt;head&gt;</code> 标签底部插入一个 <code>&lt;style&gt;</code> 标签，并把我们写的所有样式放入在这个标签里（可以这样理解）。在引入<code>@loadable/component</code>之前，工程在 Webpack 打包时，会把组件库的 css 样式提取出来单独生成一个 css 文件，并且在 html 文件中在 <code>head</code> 标签底部插入这个 css 文件链接。此时 <code>styled-components</code> 在运行时再在 <code>head</code> 底部插入一个 <code>style</code> 标签，这个标签就会在上面 css 文件链接的下面。所以根据 css 优先级规则，后插入的 <code>style</code>标签里的样式优先级更高，这个时候是没有问题的。</p>
<p>但是在引入 <code>@loadable/component</code> 之后，上面的过程不变（第一步提取的 css 样式可能会变小，因为要按需加载打包），在切换路由的时候，会自动去加载新路由下需要的静态资源文件，包括 js 和 css，这个时候依然 <code>loadable</code> 也会在 <code>head</code> 底部插入 css 文件链接来加载 css 文件。但是由于这个时候插入的 css 文件位于 <code>styled-components</code>生成的<code>style</code> 标签后面，所以此时 <code>loadable</code>按需加载的优先级会更高，这也解释了上面所描述的偶现情况，切换路由新加载的css样式优先级会更高，当前页面刷新的时候，<code>styled-comoponents</code>生成<code>style</code>标签的时机在 <code>loadable</code> 之后，所以这个时候 <code>styled-components</code> 的优先级更高。</p>
<p>了解原因之后，解决方案就比较容易想到了：调整 <code>styled-components</code> 或者 <code>@loadable/component</code>插入样式的位置，保证<code>styled-components</code>的优先级始终更高一些。<br>查阅 <code>styled-components</code> 文档和Github issue之后，我们发现有两种方案可以尝试。</p>
<ol>
<li>使用<code>StyleSheetManager</code>组件包裹页面，控制默认的插入位置：<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">StyleSheetManager</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 body 底部插入样式，优先级会比head 底部的 css优先级更高 </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">StyleSheetManager</span> <span class="attr">target</span>=<span class="string">&#123;document.body&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">StyleSheetManager</span>&gt;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li>
<li>如果希望加载在 body 顶部，有一个比较 hack 的方案，可以在 html 中设置一个空的 style 标签，并带上标记<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">data-styled</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
参考 <a href="https://github.com/styled-components/styled-components/issues/3181">https://github.com/styled-components/styled-components/issues/3181</a></li>
</ol>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>对象创建模式创建--沙盒模式</title>
    <url>/2017/02/21/sandbox-pattern/</url>
    <content><![CDATA[<p>看汤姆大叔的博客，记录一下对象创建模式里的沙盒模式<br>沙盒模式即是为一个或多个模块提供单独的上下文环境，而不会影响其他模块的上下文环境，比如有个Sandbox里有3个方法event，dom，ajax，在调用其中2个组成一个环境的话，和调用三个组成的环境完全没有干扰。Sandbox实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sandbox</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">    <span class="comment">//最后一个参数为callback</span></span><br><span class="line">    callback = args.<span class="title function_">pop</span>(),</span><br><span class="line">    <span class="comment">//除最后一个参数外，其他均为要选择的模块</span></span><br><span class="line">    modules = (args[<span class="number">0</span>] &amp;&amp; <span class="keyword">typeof</span> args[<span class="number">0</span>] === <span class="string">&#x27;string&#x27;</span>) ? args : args[<span class="number">0</span>],</span><br><span class="line">    i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//强制使用new 操作符</span></span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Sandbox</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sandbox</span>(modules, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向this对象上添加模块</span></span><br><span class="line">    <span class="comment">//如果没有传模块或者传入的参数为&quot;*&quot;，则认为传入所有模块</span></span><br><span class="line">    <span class="keyword">if</span>(!modules || modules == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">      modules = [];</span><br><span class="line">      <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="title class_">Sandbox</span>.<span class="property">moduls</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Sandbox</span>.<span class="property">modules</span>.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line">          modules.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化需要的模块</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;modules.<span class="property">length</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="title class_">Sandbox</span>.<span class="property">modules</span>[modules[i]](<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用callback</span></span><br><span class="line">    <span class="title function_">callback</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认添加原型对象</span></span><br><span class="line"><span class="title class_">Sandbox</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;My Application&#x27;</span>,</span><br><span class="line">  <span class="attr">version</span>: <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>然后在定义默认的初始模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Sandbox</span>.<span class="property">modules</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sandbox</span>.<span class="property">modules</span>.<span class="property">dom</span> = <span class="keyword">function</span>(<span class="params">box</span>) &#123;</span><br><span class="line">  box.<span class="property">getElement</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  box.<span class="property">getStyle</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  box.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sandbox</span>.<span class="property">modules</span>.<span class="property">event</span> = <span class="keyword">function</span>(<span class="params">box</span>) &#123;</span><br><span class="line">  box.<span class="property">attachEvent</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  box.<span class="property">detachEvent</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sandbox</span>.<span class="property">modules</span>.<span class="property">ajax</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  box.<span class="property">makeRequest</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  box.<span class="property">getResponse</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Sandbox</span>([<span class="string">&#x27;ajax&#x27;</span>, <span class="string">&#x27;event&#x27;</span>], <span class="keyword">function</span>(<span class="params">box</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> box.<span class="property">foo</span>); <span class="comment">//undefined  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sandbox</span>(<span class="string">&#x27;ajax&#x27;</span>, <span class="string">&#x27;dom&#x27;</span>, <span class="keyword">function</span>(<span class="params">box</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> box.<span class="property">attachEvent</span>) <span class="comment">//undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sandbox</span>(<span class="string">&#x27;*&#x27;</span>, <span class="keyword">function</span>(<span class="params">box</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(box); <span class="comment">//所有方法对象</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn resolutions</title>
    <url>/2021/08/01/yarn-resolutions/</url>
    <content><![CDATA[<p>Yarn 支持在工程的 package.json 文件中的 <code>resolutions</code> 字段里指定包的特定版本或者版本范围。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>可能工程里的某个依赖的包A不是经常更新，但是这个包所依赖的包B有一个重要更新。这这种情况下，如果这个包A指定的依赖包B的版本范围没有覆盖到包B的最新版本的话，即重新安装依赖时，也不会安装到最新的包B，这时我们可能就要一直等待包A的作者更新了。</li>
<li>当工程里的子依赖有一个重要的安全方面的更新，并且你不想等你直接依赖的包更新时</li>
<li>当工程中某个依赖包正常运行，但是作者不再维护了。如果这个包某个依赖包有更新时，而且我们需要这个更新时。</li>
<li>当工程中某个依赖包定义了一个很大范围的版本时，如果子依赖此时更新了一个最新版本存在bug，我们想退回之前的版本时，</li>
</ul>
<blockquote>
<p>总的来说就是，我们希望指定工程直接依赖里的某个子依赖包的版本时，可以使用 <code>resolutions</code></p>
</blockquote>
<span id="more"></span>

<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在 <code>package.json</code> 文件中添加 <code>resolutions</code> 字段，在该字段下指定我们希望的版本：</p>
<p>package.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;project&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;left-pad&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;c&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file:../c-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;d2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file:../d2-1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;resolutions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;d2/left-pad&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;c/**/left-pad&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.1.2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后执行 <code>yarn install</code>。</p>
<p>意思是说可以直接指定依赖 d2 所依赖的 left-pad 版本为 1.1.1。可惜 npm 官方并不支持这个参数，不过 github 上有一个第三方库支持了这个功能。</p>
]]></content>
      <tags>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>Varnish 入门</title>
    <url>/2019/03/13/varnish-learn/</url>
    <content><![CDATA[<p>Varnish是一款高性能、开源的反向代理服务器，支持负载均衡，经常被用作缓存服务，能够极大的提高网站的响应速度。</p>
<p>Varnish 进程分为master进程和worker进程，master进程负责读取配置文件、创建和管理子进程等，worker进程则负责处理请求。一旦子进程挂了，master进程会立即重新启动子进程。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>mac 上安装可以使用Homebrew</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew install varnish</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>启动命令（后台运行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew services start varnish</span><br></pre></td></tr></table></figure>

<p>默认端口是8080，可以在plist中修改端口</p>
<p><code>~/Library/LaunchAgents/homebrew.mxcl.varnish.plist</code></p>
<ul>
<li>n：运行目录路径</li>
<li>f: 配置文件路径</li>
<li>a: 启动端口</li>
<li>s：缓存方式</li>
</ul>
<p>varnish的默认配置文件位置位于<code>/usr/local/etc/varnish/default.vcl</code></p>
<p>通过homebrew安装的varnish，在调试配置文件时使用varnishlog会提示<code>VSM: Could not get hold of varnishd, is it running?</code></p>
<h2 id="Varnish-配置语言-VCL"><a href="#Varnish-配置语言-VCL" class="headerlink" title="Varnish 配置语言 VCL"></a>Varnish 配置语言 VCL</h2><h3 id="运算符-Operator"><a href="#运算符-Operator" class="headerlink" title="运算符 Operator"></a>运算符 Operator</h3><ul>
<li>&#x3D; 赋值</li>
<li>&#x3D;&#x3D; 比较</li>
<li>~ 匹配，可以使用正则表达式，或者ACLs</li>
<li>! 否定</li>
<li>&amp;&amp; 逻辑与</li>
<li>|| 逻辑或</li>
</ul>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul>
<li>if、else、elseif（elsif | elif | else if 四个都一样）</li>
<li><strong>没有循环语句</strong></li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>五种数据类型：String， boolean，time，duration，integer</li>
<li>使用<code>set</code> 和 <code>unset</code> 设置或者移除</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set req.http.User-Agent = &quot;unknown&quot;;</span><br><span class="line">unset req.http.Range;</span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li>基本的字符串形式使用双引号 “…”，不允许跨行</li>
<li>反斜杆不是特殊符号，所以不需要对反斜杠进行转义</li>
<li>比较长的字符串可以使用{“…”}，可以包含双引号、换行符等，不包含NUL（0x00）</li>
</ul>
<h4 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h4><ul>
<li>now 函数返回当前时间</li>
<li>在字符串上下文，返回格式化的字符串</li>
</ul>
<h4 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h4><p>number + 时间单位，比如： 1.5w</p>
<ul>
<li>ms: milliseconds</li>
<li>s: seconds</li>
<li>m: minutes</li>
<li>h: hours</li>
<li>d: days</li>
<li>w: weeks</li>
<li>y: years</li>
</ul>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>Varnish 使用 Perl-compatible regular expressions（pcre）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (req.http.host !~ &quot;(?i)example\.com$&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="include-引入VCL文件"><a href="#include-引入VCL文件" class="headerlink" title="include 引入VCL文件"></a>include 引入VCL文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include &quot;foo.vcl&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="import-加载-Varnish模块（VMODS）"><a href="#import-加载-Varnish模块（VMODS）" class="headerlink" title="import 加载 Varnish模块（VMODS）"></a>import 加载 Varnish模块（VMODS）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import std;</span><br><span class="line">sub vcl_recv &#123;</span><br><span class="line">    std.log(&quot;foo&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>单行注释： <code>#</code>、 <code>||</code> </li>
<li>多行注释： <code>/* block */</code></li>
</ul>
<h3 id="定义-backend"><a href="#定义-backend" class="headerlink" title="定义 backend"></a>定义 backend</h3><p>varnish中的backend 和 nginx里 upstream 中 server概念很像，一个backend对象指定服务的host和端口，包括类似于健康检查的机制</p>
<p>定义一个 backend 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backend name &#123;</span><br><span class="line">    .attribute = &quot;value&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用属性有 host（必填）、port、probe（类似于健康检查机制，后面会写到）</p>
<h3 id="定义-Probes"><a href="#定义-Probes" class="headerlink" title="定义 Probes"></a>定义 Probes</h3><p>probe 用于 请求 backend 状态，backend返回的状态不符合预期，则会标记该backend下线</p>
<p>定义一个name为 healthcheck的 probe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">probe healthcheck &#123;</span><br><span class="line">    .url = &quot;/health/check&quot;;</span><br><span class="line">    .timeout = 2s;</span><br><span class="line">    .interval = 5s;</span><br><span class="line">    .expected_response = 200; # 服务正常返回的http状态码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合 backend使用，定义一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backend default &#123;</span><br><span class="line">    .host: &quot;127.0.0.1&quot;;</span><br><span class="line">    .port: 8080;</span><br><span class="line">    .probe: healthcheck;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="director-多个后端集合，负载均衡"><a href="#director-多个后端集合，负载均衡" class="headerlink" title="director 多个后端集合，负载均衡"></a>director 多个后端集合，负载均衡</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">director fed round-robin &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .backend = fed1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        .backend = fed2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="acl-权限控制列表（Access-control-lists）"><a href="#acl-权限控制列表（Access-control-lists）" class="headerlink" title="acl 权限控制列表（Access control lists）"></a>acl 权限控制列表（Access control lists）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acl local &#123;</span><br><span class="line">    &quot;localhost&quot;;</span><br><span class="line">    &quot;127.0.0.1&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配ip地址的时候，使用匹配运算符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (client.ip ~ local) &#123;</span><br><span class="line">    return (pipe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子程序-Subroutines"><a href="#子程序-Subroutines" class="headerlink" title="子程序 Subroutines"></a>子程序 Subroutines</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub pip_if_local &#123;</span><br><span class="line">    if (client.ip ~ local) &#123;</span><br><span class="line">        return (pipe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子程序中不能引入参数，也没有返回值</li>
<li>varnish 内置子程序 命名为vcl.*，自定义子程序不能以<code>vcl</code>开头</li>
<li>调用子程序，使用关键字 <code>call</code> 后面跟上子程序名字<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call pip_if_local;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="几个常用的内置子程序"><a href="#几个常用的内置子程序" class="headerlink" title="几个常用的内置子程序"></a>几个常用的内置子程序</h2><h3 id="vcl-recv"><a href="#vcl-recv" class="headerlink" title="vcl_recv"></a>vcl_recv</h3><p>用于接收和处理请求。</p>
<p>举个栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub vcl_recv &#123;</span><br><span class="line">    if (req.url ~ &quot;/public/&quot;) &#123;</span><br><span class="line">        return (hash);</span><br><span class="line">    &#125;</span><br><span class="line">    return (pass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码将请求中匹配<code>/public/</code>的请求，进入hash阶段，请求转到<code>vcl_hash</code>，其余请求进入pass模式，处理转到<code>vcl_pass</code></p>
<p>return 支持5个参数：</p>
<ul>
<li>hash：进入<code>vcl_hash</code></li>
<li>pass: 进入<code>vcl_pass</code></li>
<li>pipe: 进入<code>vcl_pip</code></li>
<li>synth(status code, reason)： 进入<code>vcl_synth</code></li>
<li>purge：清除缓存</li>
</ul>
<h3 id="vcl-backend-fetch"><a href="#vcl-backend-fetch" class="headerlink" title="vcl_backend_fetch"></a>vcl_backend_fetch</h3><p>在向后端发请求前执行，这个阶段可以修改请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub vcl_backedn_fetch &#123;</span><br><span class="line">    unset bereq.http.Cookie;</span><br><span class="line">    return (fetch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return 支持两个参数</p>
<ul>
<li>fetch：发送请求到后端</li>
<li>abandon： 放弃请求后端。</li>
</ul>
<h3 id="vcl-backend-response"><a href="#vcl-backend-response" class="headerlink" title="vcl_backend_response"></a>vcl_backend_response</h3><p>当从后端获取到请求响应头后执行，可以在这个阶段处理删除或添加响应头的事情。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub vcl_backend_response &#123;</span><br><span class="line">    set beresp.ttl = 5m;</span><br><span class="line">    unset beresp.http.Set-Cookie;</span><br><span class="line">    return (deliver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子设置资源的缓存时间、删除请求响应头里的Set-Cookie。<br>return 支持三个参数</p>
<ul>
<li>deliver： 返回数据给用户端</li>
<li>abandon：放弃后端请求，resp.status 为 503，进入<code>vcl_synth</code></li>
<li>retry：重试后端事务，达到最大次数限制后进入<code>vcl_backend_error</code></li>
</ul>
<h3 id="vcl-deliver"><a href="#vcl-deliver" class="headerlink" title="vcl_deliver"></a>vcl_deliver</h3><p>当从后端获取到所有信息后，在返回用户前执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub vcl_deliver &#123;</span><br><span class="line">    if (obj.hits &gt; 0) &#123;</span><br><span class="line">        set resp.http.X-Varnish-Cache = &quot;HIT&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        set resp.http.X-Varnish-Cache = &quot;MISS&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return (deliver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中判断是否是命中缓存，并在响应头中显示。<br>return支持 三个参数：</p>
<ul>
<li>deliver 返回数据给用户端</li>
<li>restart 重新启动事务。增加了重新启动计数器。如果重启的次数超过了max_restarts的设置，就会抛出一个错误</li>
<li>synth(status code, reason) 带着synth的参数resp.status和resp.reason转到vcl_synth处理。</li>
</ul>
<h3 id="vcl-init"><a href="#vcl-init" class="headerlink" title="vcl_init"></a>vcl_init</h3><p>在VCL加载完成，请求进入之前执行，一般用来初始化VMODs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import directors;    # load the directors</span><br><span class="line"></span><br><span class="line">backend server1 &#123;</span><br><span class="line">    .host = &quot;127.0.0.1&quot;;</span><br><span class="line">&#125;</span><br><span class="line">backend server2 &#123;</span><br><span class="line">    .host = &quot;xxxxxxxxx&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub vcl_init &#123;</span><br><span class="line">    new bar = directors.round_robin();</span><br><span class="line">    bar.add_backend(server1);</span><br><span class="line">    bar.add_backend(server2);</span><br><span class="line">    return (ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub vcl_recv &#123;</span><br><span class="line">    </span><br><span class="line">    set req.backend_hint = bar.backend();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>return 支持两个参数</p>
<ul>
<li>ok 正常返回，继续</li>
<li>fail 终止加载VCL</li>
</ul>
<h3 id="vcl-fini"><a href="#vcl-fini" class="headerlink" title="vcl_fini"></a>vcl_fini</h3><p>在所有请求都处理完，VCL被丢弃后执行，一般用来清理VMODS。return (ok)。</p>
<p>更多详细的内置子程序可以参考:</p>
<ul>
<li><a href="https://jefferywang.gitbooks.io/varnish_4_1_doc_zh/content/chapter4_2.html">https://jefferywang.gitbooks.io/varnish_4_1_doc_zh/content/chapter4_2.html</a></li>
<li><a href="https://varnish-cache.org/docs/4.1/users-guide/vcl-built-in-subs.html#vcl-built-in-subs">https://varnish-cache.org/docs/4.1/users-guide/vcl-built-in-subs.html#vcl-built-in-subs</a></li>
</ul>
<p>varnish的内置子程序 调用状态可以看官网的两张张图：</p>
<ul>
<li>Client端：</li>
</ul>
<p><img data-src="https://kaola-haitao.oss.kaolacdn.com/dfe8e572-93e7-4474-a8d5-a97fab3b113b_1011_1387.svg" alt="image"></p>
<ul>
<li>Backend端：</li>
</ul>
<p><img data-src="https://kaola-haitao.oss.kaolacdn.com/9ef88c3c-bdb2-455c-afc0-df24e71e53c6_976_913.svg" alt="image"></p>
<h2 id="请求中的几个对象"><a href="#请求中的几个对象" class="headerlink" title="请求中的几个对象"></a>请求中的几个对象</h2><ul>
<li>req： 请求对象，在客户端阶段都存在</li>
<li>bereq：backend的请求，varnish在发送到backend之前构造的bereq，基于req创建</li>
<li>beresp：backend的响应对象</li>
<li>resp：返回给用户之前的响应，可以在vcl_deliver中修改</li>
<li>obj：大部分只在<code>vcl_hit</code>中，obj.hits 标识是否命中缓存，也存在于<code>vcl_deliver</code></li>
</ul>
<h2 id="调试配置文件"><a href="#调试配置文件" class="headerlink" title="调试配置文件"></a>调试配置文件</h2><p>使用std模块 和 varnishlog 可以 看到varnish 处理请求的各个状态的日志。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vcl 4.0;</span><br><span class="line">import std;</span><br><span class="line"></span><br><span class="line">sub vcl_recv &#123;</span><br><span class="line">    std.log(&quot;vcl_recv req.url: &quot; + req.url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在命令行中使用 <code>varnishlog -g raw</code>即可看到varnish处理请求的各个状态。<br>需要注意的是，<code>varnishlog</code>命令可能没有注册到全局，需要自行定位到bin文件下执行。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://varnish-cache.org/docs/4.1/reference/vcl.html#vcl-7">https://varnish-cache.org/docs/4.1/reference/vcl.html#vcl-7</a></li>
<li><a href="https://varnish-cache.org/docs/4.1/users-guide/vcl-built-in-subs.html">https://varnish-cache.org/docs/4.1/users-guide/vcl-built-in-subs.html</a></li>
<li><a href="https://jefferywang.gitbooks.io/varnish_4_1_doc_zh/content/chapter1.html">https://jefferywang.gitbooks.io/varnish_4_1_doc_zh/content/chapter1.html</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-varnish-intro/index.html">https://www.ibm.com/developerworks/cn/opensource/os-cn-varnish-intro/index.html</a></li>
</ul>
]]></content>
      <tags>
        <tag>varnish</tag>
        <tag>缓存服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 入门</title>
    <url>/2022/09/09/yuque/Flutter%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="一、HelloWorld"><a href="#一、HelloWorld" class="headerlink" title="一、HelloWorld"></a>一、HelloWorld</h2><p>演示</p>
<h2 id="二、开发环境"><a href="#二、开发环境" class="headerlink" title="二、开发环境"></a>二、开发环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line"><span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="三、基础组件"><a href="#三、基础组件" class="headerlink" title="三、基础组件"></a>三、基础组件</h2><h4 id="1-Widget"><a href="#1-Widget" class="headerlink" title="1. Widget"></a>1. Widget</h4><p><img data-src="https://image.soonwang.cn/blog/Fomlx3Hx0tt9qQIi36qgKTrDwmBJ.svg"><br>State 生命周期如下：<br><img data-src="https://image.soonwang.cn/blog/FtPEC6MFor0AvA3f0Qtno1QADBcN.png"></p>
<h4 id="2-Text、TextSpan、WidgetSpan"><a href="#2-Text、TextSpan、WidgetSpan" class="headerlink" title="2. Text、TextSpan、WidgetSpan"></a>2. Text、TextSpan、WidgetSpan</h4><ul>
<li>Text 显示文字</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Text(</span><br><span class="line">	<span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">  textAlign: TextAlign.left,</span><br><span class="line">  maxLines: <span class="number">1</span>,</span><br><span class="line">  overflow: TextOverflow.ellipise,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">  	color: Colors.blue,</span><br><span class="line">    fontSize: <span class="number">10</span>,</span><br><span class="line">    ...</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>实际开发过程中，还会有一个 Text 不同部分安装不同样式显示，可以用 TextSpan</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Text.rich(</span><br><span class="line">  TextSpan(</span><br><span class="line">    children: [</span><br><span class="line">      TextSpan(</span><br><span class="line">        text: <span class="string">&#x27;Title&#x27;</span>,</span><br><span class="line">        style: TextStyle(</span><br><span class="line">        	color: Color(<span class="number">0xff000000</span>),</span><br><span class="line">          fontWeight: bold,</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">      TextSpan(</span><br><span class="line">      	text: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">        style: TextStyle(</span><br><span class="line">          color: Colors.blue,</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// WidgetSpan 可以实现行内元素的效果</span></span><br><span class="line">      WidgetSpan(</span><br><span class="line">      	child: Container(</span><br><span class="line">        	...</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    ]</span><br><span class="line">	)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="3-Button、Image"><a href="#3-Button、Image" class="headerlink" title="3. Button、Image"></a>3. Button、Image</h4><ul>
<li>Button</li>
</ul>
<p>Flutter 提供了几种样式的 Button，也支持自定义外观</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  child: Text(<span class="string">&quot;normal&quot;</span>),</span><br><span class="line">  onPressed: () &#123;&#125;,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 扁平按钮</span></span><br><span class="line">FlatButton(</span><br><span class="line">  child: Text(<span class="string">&quot;normal&quot;</span>),</span><br><span class="line">  onPressed: () &#123;&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 默认有一个边框</span></span><br><span class="line">OutlineButton(</span><br><span class="line">  child: Text(<span class="string">&quot;normal&quot;</span>),</span><br><span class="line">  onPressed: () &#123;&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// icon 按钮</span></span><br><span class="line">IconButton(</span><br><span class="line">  icon: Icon(Icons.thumb_up),</span><br><span class="line">  onPressed: () &#123;&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>Image</li>
</ul>
<p>Image 组件用来显示图片，数据源可以是 assets、文件、网络<br>Image 对加载过的图片会有缓存（内存），默认缓存数量是 1000，最大缓存空间是 100M</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载本地文件</span></span><br><span class="line">Image(</span><br><span class="line">	image: AssetImage(<span class="string">&#x27;assets/images/3.0x/kaola.png&#x27;</span>),</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 快捷</span></span><br><span class="line">Image.assets(</span><br><span class="line">  <span class="string">&#x27;assets/images/3.0x/kaola.png&#x27;</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载网络图片</span></span><br><span class="line"></span><br><span class="line">Image(</span><br><span class="line">	image: NetworkImage(<span class="string">&#x27;<span class="subst">$imageUrl</span>&#x27;</span>),</span><br><span class="line">  width: <span class="number">100.0</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 快捷</span></span><br><span class="line">Image.network(</span><br><span class="line">	<span class="string">&#x27;<span class="subst">$imageUrl</span>&#x27;</span>,</span><br><span class="line">  width: <span class="number">100.0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="3-表单、输入框、单选、复选"><a href="#3-表单、输入框、单选、复选" class="headerlink" title="3. 表单、输入框、单选、复选"></a>3. 表单、输入框、单选、复选</h4><h4 id="4-布局组件"><a href="#4-布局组件" class="headerlink" title="4. 布局组件"></a>4. 布局组件</h4><ul>
<li>线性布局：Row、Column</li>
<li>弹性布局：Flex、Expanded</li>
<li>流式布局：Wrap、Flow</li>
<li>层叠布局（绝对定位）：Stack、Position</li>
<li>对齐：Align</li>
</ul>
<h4 id="5-容器类组件"><a href="#5-容器类组件" class="headerlink" title="5. 容器类组件"></a>5. 容器类组件</h4><ul>
<li>Container 类似 div</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中 decoration constraints transform padding 都有对应的单独的Box类</span></span><br><span class="line">Container(</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">100</span>,</span><br><span class="line">  color: Colors.white, <span class="comment">// 背景色</span></span><br><span class="line">  padding: EdgeInsets.fromLTRB(<span class="number">20</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">10</span>),</span><br><span class="line">  margin: EdgeInsets.fromLTRB(<span class="number">20</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="comment">// 背景装饰（圆角、背景色、boxShadow等）</span></span><br><span class="line">	decoration: BoxDecoration(</span><br><span class="line">    borderRadius: BorderRadius.all(Radius.circular(<span class="number">20</span>)),</span><br><span class="line">    color: Color(<span class="number">0xffffe030</span>),</span><br><span class="line">  ),</span><br><span class="line">  <span class="comment">// 大小限制</span></span><br><span class="line">  constraints: BoxConstraints(</span><br><span class="line">    maxWidth: <span class="number">50</span>,</span><br><span class="line">    minWidth: <span class="number">50</span></span><br><span class="line">  ),</span><br><span class="line">  <span class="comment">// 变换</span></span><br><span class="line">  transform: Matrix4.translationValues(<span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">  child: Text(</span><br><span class="line">    <span class="string">&#x27;<span class="subst">$labelValue</span>&#x27;</span>,</span><br><span class="line">    style: TextStyle(</span><br><span class="line">      fontSize: <span class="number">13</span>,</span><br><span class="line">      fontWeight: FontWeight.w500,</span><br><span class="line">      color: Colors.black,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="6-可滚动组件"><a href="#6-可滚动组件" class="headerlink" title="6. 可滚动组件"></a>6. 可滚动组件</h4><ul>
<li>ListView</li>
<li>GridView</li>
<li>SingleChildScrollView</li>
<li>CustomScrollView</li>
</ul>
<h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><h4 id="1-MaterialPageRoute"><a href="#1-MaterialPageRoute" class="headerlink" title="1. MaterialPageRoute"></a>1. MaterialPageRoute</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push( context,</span><br><span class="line">  MaterialPageRoute(</span><br><span class="line">    builder: (context) &#123;</span><br><span class="line">      <span class="keyword">return</span> NewRoute(); <span class="comment">// page</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 包含路由信息，name，arguments</span></span><br><span class="line">    settings: RouteSettings(</span><br><span class="line">    	name: <span class="string">&#x27;xx&#x27;</span>,</span><br><span class="line">      arguments: &#123;<span class="string">&#x27;xx&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;</span><br><span class="line">    ),</span><br><span class="line">    maintainState: <span class="keyword">true</span>, <span class="comment">// 默认进入下个路由时，原来路由仍然会保存在内存中</span></span><br><span class="line">    fullscreenDialog: <span class="keyword">false</span>, <span class="comment">// 是否是全屏对话框</span></span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="2-Navigator"><a href="#2-Navigator" class="headerlink" title="2. Navigator"></a>2. Navigator</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push(BuildContext context, Route route);</span><br><span class="line">Navigator.pop(BuildContext context, [result]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> Navigator.push(context, xxx);</span><br><span class="line">Navigator.pop(context, <span class="string">&#x27;返回值xxx&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-命名路由"><a href="#3-命名路由" class="headerlink" title="3. 命名路由"></a>3. 命名路由</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">  theme: ThemeData(</span><br><span class="line">    primarySwatch: Colors.blue,</span><br><span class="line">  ),</span><br><span class="line">  <span class="comment">//注册路由表</span></span><br><span class="line">  routes:&#123;</span><br><span class="line">   <span class="string">&quot;new_page&quot;</span>:(context) =&gt; NewRoute(),</span><br><span class="line">    ... <span class="comment">// 省略其它路由注册信息</span></span><br><span class="line">  &#125; ,</span><br><span class="line">  home: MyHomePage(title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开命名路由</span></span><br><span class="line">Navigator.pushNamed(context, <span class="string">&#x27;new_page&#x27;</span>, arguments: <span class="string">&#x27;xxxx&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="4-命名路由-Hook"><a href="#4-命名路由-Hook" class="headerlink" title="4. 命名路由 Hook"></a>4. 命名路由 Hook</h4><blockquote>
<p>如果指定的路由名在路由表中已注册，则会调用路由表中的 builder 函数来生成路由组件；<br>如果路由表中没有注册，才会调用 onGenerateRoute 来生成路</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  ... <span class="comment">//省略无关代码</span></span><br><span class="line">  onGenerateRoute:(RouteSettings settings)&#123;</span><br><span class="line">      <span class="keyword">return</span> MaterialPageRoute(builder: (context)&#123;</span><br><span class="line">           <span class="built_in">String</span> routeName = settings.name;</span><br><span class="line">       <span class="comment">// 如果访问的路由页需要登录，但当前未登录，则直接返回登录页路由，</span></span><br><span class="line">       <span class="comment">// 引导用户登录；其它情况则正常打开路由。</span></span><br><span class="line">     &#125;</span><br><span class="line">   );</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="五、网络请求"><a href="#五、网络请求" class="headerlink" title="五、网络请求"></a>五、网络请求</h2><h4 id="1-Dio-库"><a href="#1-Dio-库" class="headerlink" title="1. Dio 库"></a>1. Dio 库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  dio: 3.x #latest version</span><br></pre></td></tr></table></figure>

<ul>
<li>基础使用</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get 请求</span></span><br><span class="line">Response res = <span class="keyword">await</span> Dio().<span class="keyword">get</span>(<span class="string">&#x27;https://www.kaola.com&#x27;</span>, queryParameters: &#123;</span><br><span class="line">	<span class="string">&quot;xx&quot;</span>: <span class="string">&quot;xx&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// post 请求</span></span><br><span class="line">Response res = <span class="keyword">await</span> Dio().post(<span class="string">&#x27;https://wwww.kaola.com/api&#x27;</span>, data: &#123;</span><br><span class="line">	<span class="string">&#x27;xx&#x27;</span>: <span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>BaseOptions</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Dio dio = Dio(BaseOptions(</span><br><span class="line">  baseUrl: <span class="string">&#x27;https://mocks.alibaba-inc.com/mock/kaola-like&#x27;</span>,</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">));</span><br><span class="line"><span class="keyword">await</span>  dio.<span class="keyword">get</span>(<span class="string">&#x27;/xx&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> dio.post(<span class="string">&#x27;/xx&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-处理-cookie"><a href="#2-处理-cookie" class="headerlink" title="2. 处理 cookie"></a>2. 处理 cookie</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 依赖</span></span><br><span class="line"><span class="attr">dio_cookie_manager:</span> <span class="string">^1.0.0</span></span><br><span class="line"><span class="attr">cookie_jar:</span> <span class="string">^1.0.1</span></span><br><span class="line"><span class="comment"># 引入该依赖后，ios模拟器需要重新 build，可能需要进ios目录执行 pod install</span></span><br><span class="line"><span class="attr">path_provider:</span> <span class="string">^1.6.5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Dio dio = Dio(BaseOptions(</span><br><span class="line">  baseUrl: <span class="string">&#x27;https://mocks.alibaba-inc.com/mock/kaola-like&#x27;</span>,</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">));</span><br><span class="line">Directory appDocDir = <span class="keyword">await</span> getApplicationDocumentsDirectory();</span><br><span class="line"><span class="built_in">String</span> appDocPath = appDocDir.path;</span><br><span class="line"><span class="keyword">var</span> cookieJar = PersistCookieJar(dir: <span class="string">&#x27;<span class="subst">$appDocPath</span>/.cookies/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">dio.interceptors.add(CookieManager(cookieJar));</span><br></pre></td></tr></table></figure>

<h4 id="3-json-转-model"><a href="#3-json-转-model" class="headerlink" title="3. json 转 model"></a>3. json 转 model</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> email;</span><br><span class="line"></span><br><span class="line">  User(<span class="keyword">this</span>.name, <span class="keyword">this</span>.email);</span><br><span class="line"></span><br><span class="line">  User.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json)</span><br><span class="line">      : name = json[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">        email = json[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; toJson() =&gt;</span><br><span class="line">    &lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&#123;</span><br><span class="line">      <span class="string">&#x27;name&#x27;</span>: name,</span><br><span class="line">      <span class="string">&#x27;email&#x27;</span>: email,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、持久化存储"><a href="#六、持久化存储" class="headerlink" title="六、持久化存储"></a>六、持久化存储</h2><h4 id="1-SharedPreferences"><a href="#1-SharedPreferences" class="headerlink" title="1. SharedPreferences"></a>1. SharedPreferences</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引入该依赖后，ios模拟器需要重新 build，可能需要进ios目录执行 pod install</span></span><br><span class="line"><span class="attr">shared_preferences:</span> <span class="string">^0.5.6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key-value 存储</span></span><br><span class="line">SharedPreferences _prefs = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line"><span class="comment">// 存 key</span></span><br><span class="line">awiat _prefs.setString(key, value);</span><br><span class="line"><span class="comment">// 读 key</span></span><br><span class="line"><span class="built_in">String</span> value = _prefs.getString(key);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2. 文件操作"></a>2. 文件操作</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path_provider</span></span><br><span class="line">Directory appDocDir = <span class="keyword">await</span> getApplicationDocumentsDirectory();</span><br><span class="line"> <span class="built_in">String</span> appDocPath = appDocDir.path;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&#x27;<span class="subst">$path</span>/counter.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="built_in">String</span> contents = <span class="keyword">await</span> file.readAsString();</span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="keyword">await</span> file.writeAsString();</span><br></pre></td></tr></table></figure>

<h2 id="七、动画"><a href="#七、动画" class="headerlink" title="七、动画"></a>七、动画</h2><ul>
<li>Animation: 主要用于保存动画插值和状态<ul>
<li>addListener(): 帧监听器，每一帧都会被调用</li>
<li>addStatusListener(): 状态改变监听器，动画开始、结束、正向或反向 时会调用状态改变监听器</li>
</ul>
</li>
<li>Curve: 用来描述动画过程</li>
<li>AnimationController: 用于控制动画，动画的启动 forward()、停止 stop()、反向播放 reverse()</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> AnimationController controller = <span class="keyword">new</span> AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>),</span><br><span class="line">  	vsync: <span class="keyword">this</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.flutterchina.club/intro.html">Flutter 实战</a></li>
<li><a href="https://flutter.dev/">Flutter 官网</a></li>
<li><a href="https://pub.dev/">Flutter 仓库</a></li>
</ul>
]]></content>
      <tags>
        <tag>flutter</tag>
        <tag>flutter 入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.$nextTick浅谈</title>
    <url>/2018/08/05/Vue.$nextTick/</url>
    <content><![CDATA[<p>依稀记得第一次接触Vue.$nextTick是在之前某个项目从Vue 1.x升级到Vue 2.x时，发现vue实例的生命周期钩子函数都变了。查阅Vue官方提供的升级文档时发现，ready被mounted钩子函数替代，文档还特别提出，mounted并不保证钩子函数中的this.$el在document中，需要使用vm.$nextTick，那时起就觉得$nextTick好神奇。今天就来谈（xia）谈（che）Vue的异步实现$nextTick。</p>
<h2 id="0-浏览器事件循环机制"><a href="#0-浏览器事件循环机制" class="headerlink" title="0 浏览器事件循环机制"></a>0 浏览器事件循环机制</h2><p>在谈$nextTick之前，当然要先温习一下浏览器的事件循环啦。ps：各位对浏览器事件循环机制了如指掌的看官可以直接跳过了。</p>
<h3 id="0-1-单线程和异步"><a href="#0-1-单线程和异步" class="headerlink" title="0.1 单线程和异步"></a>0.1 单线程和异步</h3><p>我们都知道js是单线程的，js引擎负责解释执行js的只有一个线程，就是我们所谓的主线程，而一些异步回调函数会被放到任务队列中，当主线程空闲时，会执行任务队列中的回调函数。</p>
<h3 id="0-2-tasks-macroTasks-和-microTasks"><a href="#0-2-tasks-macroTasks-和-microTasks" class="headerlink" title="0.2 tasks (macroTasks) 和 microTasks"></a>0.2 tasks (macroTasks) 和 microTasks</h3><p>event loop中有两种类型的任务队列，tasks（macroTasks）和mircroTasks。</p>
<ul>
<li>tasks: 执行主线程js代码、网络请求、页面加载、输入、点击事件以及定时器事件（setTimeout,setIntervel,setImmediate）等。</li>
<li>microTasks: 更新应用程序状态的任务，常见的有promise，process.nextTick，MutationObserver，Object.observe等</li>
</ul>
<span id="more"></span>

<h3 id="0-3-来做个题吧"><a href="#0-3-来做个题吧" class="headerlink" title="0.3 来做个题吧"></a>0.3 来做个题吧</h3><p>先看下面的js代码，写出执行执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;script start&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;);</span><br><span class="line">  Promise.resolve().then(function()&#123;</span><br><span class="line">      console.log(&#x27;promise in setTimeout&#x27;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;);</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;setTimeout in promise1&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&#x27;promise2&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;script end&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="0-4-event-loop-处理顺序"><a href="#0-4-event-loop-处理顺序" class="headerlink" title="0.4 event loop 处理顺序"></a>0.4 event loop 处理顺序</h3><p>ps: 觉得毫无难度的大大可以跳过了。<br>执行的结果是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br><span class="line">promise <span class="keyword">in</span> setTimeout</span><br><span class="line">setTimeout <span class="keyword">in</span> promise1</span><br></pre></td></tr></table></figure>

<p>先看下“圣经”的解释（颤颤抖抖打开为<a href="https://www.w3.org/TR/2017/REC-html52-20171214/webappapis.html#event-loops-processing-model">w3c</a>）</p>
<blockquote>
<ol>
<li>Select the oldest task on one of the event loop’s task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue. If there is no task to select, then jump to the Microtasks step below.</li>
<li>Set the event loop’s currently running task to the task selected in the previous step.</li>
<li>Run: Run the selected task.</li>
<li>Set the event loop’s currently running task back to null.</li>
<li>Remove the task that was run in the Run step above from its task queue.</li>
<li>Microtasks: Perform a microtask checkpoint.</li>
<li>Update the rendering: If this event loop is a browsing context event loop (as opposed to a Worker event loop), then run the following substeps.（此处省略，感兴趣的大佬请移步w3c）</li>
<li>If this is a Worker event loop (i.e., one running for a WorkerGlobalScope), but there are no tasks in the event loop’s task queues and the WorkerGlobalScope object’s closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps.</li>
<li>Return to the first step of the event loop.</li>
</ol>
</blockquote>
<p>好了，上面解释的很清楚了，我就不翻译了（各位大大英语肯定都比我好，逃）<br>下面放上一张网上盗的图<br><img data-src="https://kaola-haitao.oss.kaolacdn.com/7957a9f2-0988-4d29-a87f-39956c294552_436_529.jpg" alt="image"></p>
<p>总结起来就是，在一次事件循环里</p>
<ul>
<li>先判断macroTask queue是否为空，空的话直接下一步，不为空的话只取出一个task执行，执行完下一步</li>
<li>再判断microTask queue是否为空，空的话直接下一步，不为空的话会取出一个task执行，执行完重复这一步，直到队列为空</li>
<li>更新渲染</li>
</ul>
<h2 id="1-Vue-nextTick"><a href="#1-Vue-nextTick" class="headerlink" title="1. Vue.$nextTick"></a>1. Vue.$nextTick</h2><h3 id="1-1-nextTick-使用"><a href="#1-1-nextTick-使用" class="headerlink" title="1.1  nextTick 使用"></a>1.1  nextTick 使用</h3><p>这里引用一下Vue官网文API上的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 修改数据</span><br><span class="line">vm.msg = &#x27;Hello&#x27;</span><br><span class="line">// DOM 还没有更新</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  // DOM 更新了</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(function () &#123;</span><br><span class="line">    // DOM 更新了</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
</blockquote>
<p>为什么在修改了数据之后DOM没有立即更新，而立即使用nextTick就能在回调里获取到更新后的DOM呢。带着这样的疑问我们先去看下nextTick的实现。</p>
<h3 id="1-2-nextTick-实现"><a href="#1-2-nextTick-实现" class="headerlink" title="1.2 nextTick 实现"></a>1.2 nextTick 实现</h3><p>目前我看的vue代码版本是2.5.17-beta.0，此版本中nextTick的实现在 <code>src/core/util/next-tick.js</code>中。源码100+行，这里就不贴了，感兴趣的童鞋请<a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js">移步</a>。<br>nextTick文件暴露了两个函数，nextTick和witchMacroTask。先看nextTick</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function nextTick (cb?: Function, ctx?: Object) &#123;</span><br><span class="line">  let _resolve</span><br><span class="line">  callbacks.push(() =&gt; &#123;</span><br><span class="line">    if (cb) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, ctx, &#x27;nextTick&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending = true</span><br><span class="line">    if (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // $flow-disable-line</span><br><span class="line">  if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>先判断cb是否存在，存在则返回callbacks数组里</li>
<li>判断!pending，即判断上一次异步回调是否已执行，若已执行，再判断是否使用macroTask（默认不），决定添加到macroTask还是microTask</li>
<li>如果cb不存在且浏览器支持Promise，则返回Promise</li>
</ol>
<p>next-tick文件里有个变量 <code>callbacks</code>, <code>callbacks</code>是一个任务队列，nextTick会把cb都放入到这个队列里。使用callbacks而不是在nextTick中直接执行回调函数的原因是保证在同一个nexTick内执行完之前tick的所有异步任务，将多个异步任务压成一个同步任务，在下一个tick执行完毕。</p>
<p>flushCallbacks用于遍历callbacks并执行回调，并将pending设置为false，表示可以开始下一个tick。</p>
<p>macroTimerFunc会依次从setImmediate，MessageChannel，setTimeout中取，而microTimerFunc则先检测浏览器是否原生支持Promise，不支持则指向macroTimerFunc的实现。这两个函数中都会异步调用flushCallbacks，默认使用microTimerFunc。</p>
<p>看到这里，我们大概知道了nextTick做的事情了，可是之前的疑问还是没有得到答案啊，为什么修改了数据之后，需要在下一个tick里才会更新呢？好吧，接下来再去扒一扒源码。</p>
<h2 id="2-响应式原理"><a href="#2-响应式原理" class="headerlink" title="2. 响应式原理"></a>2. 响应式原理</h2><p>Vue使用Object.defineProperty把对象的属性转为getter&#x2F;setter，这是响应式的核心，也是Vue不支持IE8以及更低版本浏览器的原因。下面是从官网盗的一张图。<br><img data-src="https://kaola-haitao.oss.kaolacdn.com/58ee9280-643d-45e7-86dd-2f9f2726ff13_1200_750.png" alt="image"></p>
<p>从上图可以知道，Data变化之后会Notify Watcher，而Watcher又会触发re-render。哦，原来是这样，但是还是不知道为什么修改Data之后一定要nextTick，Dom才会更新啊，继续低头扒代码…</p>
<h3 id="2-1-Observer"><a href="#2-1-Observer" class="headerlink" title="2.1 Observer"></a>2.1 Observer</h3><p>Vue的Observer类的实现在<code>src/core/observer/index.js</code>，为了省点墨水这里就不填代码了，少侠请<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js">移步</a>。</p>
<p><img data-src="https://kaola-haitao.oss.kaolacdn.com/c1bb3289-6c83-4279-b2eb-559600384d20_2118_1262.jpg" alt="image"></p>
<p>上面这张图是我根据代码画的（这么丑一看就知道肯定自己画的，凑合着看）。</p>
<p>Observer类的主要作用是给对象的属性添加getter和setter，收集依赖和派发更新。<br>defineReactive方法最为重要，它就实现了给对象属性添加getter和setter，收集依赖和派发更新。下面截取关键的源码（有删减）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        if (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          if (Array.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      if (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以发现，defineReactive在getter和setter方法中分别实现了依赖收集和更新派发。</p>
<p>getter中执行完原getter之后，先判断Dep.target，在dep.depend()，并把val也都设置成响应式并收集了依赖。厉害啊！哎等等，Dep.target是什么？为什么要先判断这个呢？</p>
<p>setter中先判断val是否有改变，执行完原setter后（将newVal也设成响应式），dep.notify()。奥，仿佛明白了什么…</p>
<p>哎喂，Dep是什么？一开始都没说啊，从哪冒出来的？别急，我们接着看</p>
<h3 id="2-2-Dep"><a href="#2-2-Dep" class="headerlink" title="2.2 Dep"></a>2.2 Dep</h3><p>Dep类的实现在<code>src/core/observer/dep.js</code>，照例，少侠请<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/dep.js">移步</a>。</p>
<p>照例，上图</p>
<p><img data-src="https://kaola-haitao.oss.kaolacdn.com/a628c51f-1321-4228-8938-b5b2321d346f_800_1072.jpg" alt="image"></p>
<p>图上很明显（强行很明显），能找到上面Observer defineReactive方法用到的那几个方法，depend,notify,以及静态属性Dep.target，这下全明白了吧？并没有，Dep.target默认是null，不可能一直是null的呀，一直是null的话，那defineReactive的判断永远不会true啊。还有，subs是啥，notify里怎么还能update呢？哎，接着看吧emmmmm…</p>
<h3 id="2-3-Watcher"><a href="#2-3-Watcher" class="headerlink" title="2.3 Watcher"></a>2.3 Watcher</h3><p>Watcher类的实现在<code>src/core/observer/watcher.js</code>，你懂的，请<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js">移步</a>。</p>
<p><img data-src="https://kaola-haitao.oss.kaolacdn.com/95ab0e44-2624-46fb-8fd6-f0c0f0313ba8_2326_1596.jpg" alt="image"></p>
<p>Watcher有众多属性，其中deep,computed,user,sync,before对某些流程会有些影响的。对于普通的Watcher（非computed），constructor时会执行get方法。</p>
<p>get方法里我们一眼看到了pushTarget(this)，popTarget()，正是上面Dep中所看到的。讲道理，在Observer的defineReactive方法中，getter时判断Dep.target是否为空，不为空才会收集依赖，而此处成对出现的pushTarget和popTarget仿佛就是告诉我们，get方法里，pushTarget和popTarget中间肯定会执行Observer的getter。为了方便解释，贴一下get的代码（有删减）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushTarget(this)</span><br><span class="line">let value</span><br><span class="line">const vm = this.vm</span><br><span class="line">try &#123;</span><br><span class="line">    value = this.getter.call(vm, vm)</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    throw e</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    popTarget()</span><br><span class="line">    this.cleanupDeps()</span><br><span class="line">&#125;</span><br><span class="line">return value</span><br></pre></td></tr></table></figure>
<p>看过来看过去，最可疑的就是try的那一句 <code>this.getter.call(vm, vm)</code>。看下constructor中，原来this.getter是从expOrFn来的，是构造函数的第二个参数。这里先看到这里，继续看。<br>addDep，在Dep类的depend方法中，就是调用Dep.target.addDep方法，当Watcher get方法中pushTarget(this)，这个时候我们知道，此时Dep.target就是Watcher实例，addDep也就是这里addDep方法。<br>addDep将Dep的实例放入到Watcher实例的newDeps数组中，并将当前Watcher实例放入Dep实例的subs中（做了去重），实现依赖收集（好像有点绕）。</p>
<p>接下来重点来了，update方法，Dep的notify方法就是调用sub的update方法，也就是这里的update方法，定睛一看，对于普通watcher（非computed、非sync）来说，update调用的就是<code>queueWatcher(this)</code>；贴代码（删除注释）为证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  if (this.computed) &#123;</span><br><span class="line">    if (this.dep.subs.length === 0) &#123;</span><br><span class="line">      this.dirty = true</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.getAndInvoke(() =&gt; &#123;</span><br><span class="line">        this.dep.notify()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (this.sync) &#123;</span><br><span class="line">    this.run()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    queueWatcher(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那<code>queueWatcher</code>又是啥玩意呢，看到queue感到莫名的兴奋，觉得答案就在眼前！</p>
<h3 id="2-4-queueWatcher"><a href="#2-4-queueWatcher" class="headerlink" title="2.4 queueWatcher"></a>2.4 queueWatcher</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function queueWatcher (watcher: Watcher) &#123;</span><br><span class="line">  const id = watcher.id</span><br><span class="line">  if (has[id] == null) &#123;</span><br><span class="line">    has[id] = true</span><br><span class="line">    if (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // if already flushing, splice the watcher based on its id</span><br><span class="line">      // if already past its id, it will be run next immediately.</span><br><span class="line">      let i = queue.length - 1</span><br><span class="line">      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + 1, 0, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    // queue the flush</span><br><span class="line">    if (!waiting) &#123;</span><br><span class="line">      waiting = true</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，按捺不住内心的欢喜，直接贴上了代码（连注释都来不及删了）。从下往上看，果然我看到了nextTick。接着看queueWatcher做了什么（源码请移步<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/scheduler.js">scheduler</a>）</p>
<ul>
<li>看watcher是否已在队列，不在继续执行（在的话返回）</li>
<li>当前没有执行flush队列时，直接将watcher push到队列里，否则安装watch id的大小插入到队列里的相应位置（flush队列时会先排序在执行，这里插到对应位置防止顺序乱了）。</li>
<li>如果当前不在flush或者flush已结束，则开始新的flush，nextTick(flushSchedulerQueue)。</li>
<li>flushSchedulerQueue 里先按watcher id大小排序，执行watcher.run()，最后执行active 和 update的钩子函数。</li>
</ul>
<p>到这里我们好像知道了答案，修改Data之后，通知到watcher更新时，使用了nextTick去执行队列。</p>
<p>到此结束了吗？当然还没完啊，还记得那年大明湖畔的夏雨荷吗？啊呸，还记得Watcher get方法里的getter方法，到底是不是getter里执行到了Observer。哦，假装不记得的童鞋可以散了先。</p>
<h2 id="3-Vue-实例"><a href="#3-Vue-实例" class="headerlink" title="3. Vue 实例"></a>3. Vue 实例</h2><p>废话不多说，先上图</p>
<p><img data-src="https://kaola-haitao.oss.kaolacdn.com/d6b0b8fb-d4e2-4a90-a8d3-fb9f987b6008_2144_1510.svg" alt="image"></p>
<p><code>src/core/instance/index.js</code>是Vue实例的入口，Vue.prototype._init定义在<code>src/core/instance/init.js</code>，<code>_init</code>的在最后执行<code>vm.$mount()</code>,这里是将vue实例挂载到dom上的关键一步。</p>
<p>在<code>src/platforms/web/runtime/index.js</code>找到一处Vue.prototype.$mount定义（vue的编译入口有多个），这里的$mount实际调用的是<code>src/core/instance/lifecycle.js</code>中的mountComponent方法，这个方法里果然看到了两个重要的生命周期钩子函数的调用，根据Vue官网文档说明，Vue实例的挂载就应该是在两个钩子函数之间，上代码（关键代码）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updateComponent = () =&gt; &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;</span><br><span class="line">new Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">  before () &#123;</span><br><span class="line">    if (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, &#x27;beforeUpdate&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, true /* isRenderWatcher */)</span><br></pre></td></tr></table></figure>
<p>很明显，mountComponent里调用new Watcher()生成一个renderWatcher，传入的getter正是updateComponent，updateComponent里调用<code>vm._update(vm._render())</code>，继续追查。</p>
<p>在<code>src/core/instance/render.js</code>中找到<code>Vue.prototype._render</code>的定义，原来<code>_render</code>调用的是<code>vm.$createElement</code>，而<code>vm.$createElement</code>定义在initRender中，使用的<code>src/core/vdom/create-element.js</code>。好了绕了一大圈终于找到了，从代码上看，createElement最终返回的是一个vnode，而在vnode的constructor里进行赋值就会触发Data的getter，getter里的Dep.target此时正是刚new的renderWatcher，依赖收集完成（在vue实例的iniMixin已经执行过initData，data早就是响应式的了）。</p>
<p>修改数据触发更新时，renderWatcher会被push进queue里，nextTick时renderWatcher调用run方法，run方法调用getAndInvoke方法，而getAndInvoke方法会调用get方法，get方法则会执行getter，也就是updateComponent，<code>vm._render()</code>返回一个新vnode，而<code>vm._update</code>会调用<code>vm.__patch__(preVnode, vnode)</code>，重新渲染。</p>
<p>好了，终于理（che）完了。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://ustbhuangyi.github.io/vue-analysis/">Vue.js技术揭秘</a></li>
<li><a href="http://lynnelv.github.io/js-event-loop-browser">深入理解js事件循环机制（浏览器篇）</a></li>
</ul>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
