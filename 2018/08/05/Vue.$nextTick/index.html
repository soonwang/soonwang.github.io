<!doctype html><html class="theme-next pisces use-motion" lang=zh-Hans><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width, initial-scale=1, maximum-scale=1"><meta http-equiv=Cache-Control content=no-transform><meta http-equiv=Cache-Control content=no-siteapp><link href=//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css rel=stylesheet type=text/css><link href=//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href="/css/main.css?v=5.1.0" rel=stylesheet type=text/css><meta name=keywords content=javascript,Vue,><link rel="shortcut icon" type=image/x-icon href="/favicon.ico?v=5.1.0"><meta name=description content="依稀记得第一次接触Vue.$nextTick是在之前某个项目从Vue 1.x升级到Vue 2.x时，发现vue实例的生命周期钩子函数都变了。查阅Vue官方提供的升级文档时发现，ready被mounted钩子函数替代，文档还特别提出，mounted并不保证钩子函数中的this.$el在document中，需要使用vm.$nextTick，那时起就觉得$nextTick好神奇。今天就来谈（xia）谈（"><meta name=keywords content=javascript,Vue><meta property=og:type content=article><meta property=og:title content=Vue.$nextTick浅谈><meta property=og:url content=http://soonwang.cn/2018/08/05/Vue.$nextTick/index.html><meta property=og:site_name content="soonwang's blog"><meta property=og:description content="依稀记得第一次接触Vue.$nextTick是在之前某个项目从Vue 1.x升级到Vue 2.x时，发现vue实例的生命周期钩子函数都变了。查阅Vue官方提供的升级文档时发现，ready被mounted钩子函数替代，文档还特别提出，mounted并不保证钩子函数中的this.$el在document中，需要使用vm.$nextTick，那时起就觉得$nextTick好神奇。今天就来谈（xia）谈（"><meta property=og:image content=https://haitao.nos.netease.com/7957a9f2-0988-4d29-a87f-39956c294552_436_529.jpg><meta property=og:image content=https://haitao.nos.netease.com/58ee9280-643d-45e7-86dd-2f9f2726ff13_1200_750.png><meta property=og:image content=https://haitao.nos.netease.com/c1bb3289-6c83-4279-b2eb-559600384d20_2118_1262.jpg><meta property=og:image content=https://haitao.nos.netease.com/a628c51f-1321-4228-8938-b5b2321d346f_800_1072.jpg><meta property=og:image content=https://haitao.nos.netease.com/95ab0e44-2624-46fb-8fd6-f0c0f0313ba8_2326_1596.jpg><meta property=og:image content=https://haitao.nos.netease.com/d6b0b8fb-d4e2-4a90-a8d3-fb9f987b6008_2144_1510.svg><meta property=og:updated_time content=2018-08-17T16:20:27.951Z><meta name=twitter:card content=summary><meta name=twitter:title content=Vue.$nextTick浅谈><meta name=twitter:description content="依稀记得第一次接触Vue.$nextTick是在之前某个项目从Vue 1.x升级到Vue 2.x时，发现vue实例的生命周期钩子函数都变了。查阅Vue官方提供的升级文档时发现，ready被mounted钩子函数替代，文档还特别提出，mounted并不保证钩子函数中的this.$el在document中，需要使用vm.$nextTick，那时起就觉得$nextTick好神奇。今天就来谈（xia）谈（"><meta name=twitter:image content=https://haitao.nos.netease.com/7957a9f2-0988-4d29-a87f-39956c294552_436_529.jpg><script type=text/javascript id=hexo.configurations>
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script><link rel=canonical href="http://soonwang.cn/2018/08/05/Vue.$nextTick/"><title>Vue.$nextTick浅谈 | soonwang's blog</title></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-Hans><div class="container one-collumn sidebar-position-left page-post-detail"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-meta><div class=custom-logo-site-title><a href="/" class=brand rel=start><span class=logo-line-before><i></i></span> <span class=site-title>soonwang's blog</span> <span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>人丑就要多读书</p></div><div class=site-nav-toggle><button><span class=btn-bar></span> <span class=btn-bar></span> <span class=btn-bar></span></button></div><nav class=site-nav><ul id=menu class=menu><li class="menu-item menu-item-home"><a href="/" rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href=/archives rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href=/tags rel=section><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li></ul></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><div id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><link itemprop=mainEntityOfPage href="http://soonwang.cn/2018/08/05/Vue.$nextTick/"><span style=display:none itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=name content=soonwang><meta itemprop=description><meta itemprop=image content=https://haitao.nos.netease.com/6b466397-97dc-44d6-8614-893b6734b6f3.png></span> <span style=display:none itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="soonwang's blog"><span style=display:none itemprop=logo itemscope itemtype=http://schema.org/ImageObject><img style=display:none; itemprop="url image" alt="soonwang's blog"></span></span><header class=post-header><h1 class=post-title itemprop="name headline">Vue.$nextTick浅谈</h1><div class=post-meta><span class=post-time><span class=post-meta-item-icon><i class="fa fa-calendar-o"></i></span> <span class=post-meta-item-text>发表于</span><time title="Post created" itemprop="dateCreated datePublished" datetime=2018-08-05T20:02:11+08:00>2018-08-05</time></span> <span class=post-comments-count><span class=post-meta-divider>|</span> <span class=post-meta-item-icon><i class="fa fa-comment-o"></i></span> <a href=/2018/08/05/Vue.$nextTick/#comments itemprop=discussionUrl><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/08/05/Vue.$nextTick/" itemprop=commentCount></span></a></span></div></header><div class=post-body itemprop=articleBody><p>依稀记得第一次接触Vue.$nextTick是在之前某个项目从Vue 1.x升级到Vue 2.x时，发现vue实例的生命周期钩子函数都变了。查阅Vue官方提供的升级文档时发现，ready被mounted钩子函数替代，文档还特别提出，mounted并不保证钩子函数中的this.$el在document中，需要使用vm.$nextTick，那时起就觉得$nextTick好神奇。今天就来谈（xia）谈（che）Vue的异步实现$nextTick。</p><h2 id=0-浏览器事件循环机制><a href=#0-浏览器事件循环机制 class=headerlink title="0 浏览器事件循环机制"></a>0 浏览器事件循环机制</h2><p>在谈$nextTick之前，当然要先温习一下浏览器的事件循环啦。ps：各位对浏览器事件循环机制了如指掌的看官可以直接跳过了。</p><h3 id=0-1-单线程和异步><a href=#0-1-单线程和异步 class=headerlink title="0.1 单线程和异步"></a>0.1 单线程和异步</h3><p>我们都知道js是单线程的，js引擎负责解释执行js的只有一个线程，就是我们所谓的主线程，而一些异步回调函数会被放到任务队列中，当主线程空闲时，会执行任务队列中的回调函数。</p><h3 id=0-2-tasks-macroTasks-和-microTasks><a href=#0-2-tasks-macroTasks-和-microTasks class=headerlink title="0.2 tasks (macroTasks) 和 microTasks"></a>0.2 tasks (macroTasks) 和 microTasks</h3><p>event loop中有两种类型的任务队列，tasks（macroTasks）和mircroTasks。</p><ul><li>tasks: 执行主线程js代码、网络请求、页面加载、输入、点击事件以及定时器事件（setTimeout,setIntervel,setImmediate）等。</li><li>microTasks: 更新应用程序状态的任务，常见的有promise，process.nextTick，MutationObserver，Object.observe等</li></ul><a id=more></a><h3 id=0-3-来做个题吧><a href=#0-3-来做个题吧 class=headerlink title="0.3 来做个题吧"></a>0.3 来做个题吧</h3><p>先看下面的js代码，写出执行执行结果<br><figure class="highlight plain"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div><div class=line>16</div><div class=line>17</div><div class=line>18</div><div class=line>19</div></pre></td><td class=code><pre><div class=line>console.log(&apos;script start&apos;);</div><div class=line></div><div class=line>setTimeout(function() &#123;</div><div class=line>  console.log(&apos;setTimeout&apos;);</div><div class=line>  Promise.resolve().then(function()&#123;</div><div class=line>      console.log(&apos;promise in setTimeout&apos;);</div><div class=line>  &#125;)</div><div class=line>&#125;);</div><div class=line></div><div class=line>Promise.resolve().then(function() &#123;</div><div class=line>  console.log(&apos;promise1&apos;);</div><div class=line>  setTimeout(function() &#123;</div><div class=line>    console.log(&apos;setTimeout in promise1&apos;);</div><div class=line>  &#125;);</div><div class=line>&#125;).then(function() &#123;</div><div class=line>  console.log(&apos;promise2&apos;);</div><div class=line>&#125;);</div><div class=line></div><div class=line>console.log(&apos;script end&apos;);</div></pre></td></tr></table></figure></p><h3 id=0-4-event-loop-处理顺序><a href=#0-4-event-loop-处理顺序 class=headerlink title="0.4 event loop 处理顺序"></a>0.4 event loop 处理顺序</h3><p>ps: 觉得毫无难度的大大可以跳过了。<br>执行的结果是：<br><figure class="highlight bash"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div></pre></td><td class=code><pre><div class=line>script start</div><div class=line>script end</div><div class=line>promise1</div><div class=line>promise2</div><div class=line><span class=built_in>set</span>Timeout</div><div class=line>promise <span class=keyword>in</span> <span class=built_in>set</span>Timeout</div><div class=line><span class=built_in>set</span>Timeout <span class=keyword>in</span> promise1</div></pre></td></tr></table></figure></p><p>先看下“圣经”的解释（颤颤抖抖打开为<a href=https://www.w3.org/TR/2017/REC-html52-20171214/webappapis.html#event-loops-processing-model target=_blank rel=external>w3c</a>）</p><blockquote><ol><li>Select the oldest task on one of the event loop’s task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue. If there is no task to select, then jump to the Microtasks step below.</li><li>Set the event loop’s currently running task to the task selected in the previous step.</li><li>Run: Run the selected task.</li><li>Set the event loop’s currently running task back to null.</li><li>Remove the task that was run in the Run step above from its task queue.</li><li>Microtasks: Perform a microtask checkpoint.</li><li>Update the rendering: If this event loop is a browsing context event loop (as opposed to a Worker event loop), then run the following substeps.（此处省略，感兴趣的大佬请移步w3c）</li><li>If this is a Worker event loop (i.e., one running for a WorkerGlobalScope), but there are no tasks in the event loop’s task queues and the WorkerGlobalScope object’s closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps.</li><li>Return to the first step of the event loop.</li></ol></blockquote><p>好了，上面解释的很清楚了，我就不翻译了（各位大大英语肯定都比我好，逃）<br>下面放上一张网上盗的图<br><img src=https://haitao.nos.netease.com/7957a9f2-0988-4d29-a87f-39956c294552_436_529.jpg alt=image></p><p>总结起来就是，在一次事件循环里</p><ul><li>先判断macroTask queue是否为空，空的话直接下一步，不为空的话只取出一个task执行，执行完下一步</li><li>再判断microTask queue是否为空，空的话直接下一步，不为空的话会取出一个task执行，执行完重复这一步，直到队列为空</li><li>更新渲染</li></ul><h2 id=1-Vue-nextTick><a href=#1-Vue-nextTick class=headerlink title="1. Vue.$nextTick"></a>1. Vue.$nextTick</h2><h3 id=1-1-nextTick-使用><a href=#1-1-nextTick-使用 class=headerlink title="1.1 nextTick 使用"></a>1.1 nextTick 使用</h3><p>这里引用一下Vue官网文API上的例子</p><figure class="highlight plain"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div></pre></td><td class=code><pre><div class=line>// 修改数据</div><div class=line>vm.msg = &apos;Hello&apos;</div><div class=line>// DOM 还没有更新</div><div class=line>Vue.nextTick(function () &#123;</div><div class=line>  // DOM 更新了</div><div class=line>&#125;)</div><div class=line></div><div class=line>// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</div><div class=line>Vue.nextTick()</div><div class=line>  .then(function () &#123;</div><div class=line>    // DOM 更新了</div><div class=line>  &#125;)</div></pre></td></tr></table></figure><blockquote><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p></blockquote><p>为什么在修改了数据之后DOM没有立即更新，而立即使用nextTick就能在回调里获取到更新后的DOM呢。带着这样的疑问我们先去看下nextTick的实现。</p><h3 id=1-2-nextTick-实现><a href=#1-2-nextTick-实现 class=headerlink title="1.2 nextTick 实现"></a>1.2 nextTick 实现</h3><p>目前我看的vue代码版本是2.5.17-beta.0，此版本中nextTick的实现在 <code>src/core/util/next-tick.js</code>中。源码100+行，这里就不贴了，感兴趣的童鞋请<a href=https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js target=_blank rel=external>移步</a>。<br>nextTick文件暴露了两个函数，nextTick和witchMacroTask。先看nextTick<br><figure class="highlight plain"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div><div class=line>16</div><div class=line>17</div><div class=line>18</div><div class=line>19</div><div class=line>20</div><div class=line>21</div><div class=line>22</div><div class=line>23</div><div class=line>24</div><div class=line>25</div><div class=line>26</div><div class=line>27</div><div class=line>28</div></pre></td><td class=code><pre><div class=line>export function nextTick (cb?: Function, ctx?: Object) &#123;</div><div class=line>  let _resolve</div><div class=line>  callbacks.push(() =&gt; &#123;</div><div class=line>    if (cb) &#123;</div><div class=line>      try &#123;</div><div class=line>        cb.call(ctx)</div><div class=line>      &#125; catch (e) &#123;</div><div class=line>        handleError(e, ctx, &apos;nextTick&apos;)</div><div class=line>      &#125;</div><div class=line>    &#125; else if (_resolve) &#123;</div><div class=line>      _resolve(ctx)</div><div class=line>    &#125;</div><div class=line>  &#125;)</div><div class=line>  if (!pending) &#123;</div><div class=line>    pending = true</div><div class=line>    if (useMacroTask) &#123;</div><div class=line>      macroTimerFunc()</div><div class=line>    &#125; else &#123;</div><div class=line>      microTimerFunc()</div><div class=line>    &#125;</div><div class=line>  &#125;</div><div class=line>  // $flow-disable-line</div><div class=line>  if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123;</div><div class=line>    return new Promise(resolve =&gt; &#123;</div><div class=line>      _resolve = resolve</div><div class=line>    &#125;)</div><div class=line>  &#125;</div><div class=line>&#125;</div></pre></td></tr></table></figure></p><ol><li>先判断cb是否存在，存在则返回callbacks数组里</li><li>判断!pending，即判断上一次异步回调是否已执行，若已执行，再判断是否使用macroTask（默认不），决定添加到macroTask还是microTask</li><li>如果cb不存在且浏览器支持Promise，则返回Promise</li></ol><p>next-tick文件里有个变量 <code>callbacks</code>, <code>callbacks</code>是一个任务队列，nextTick会把cb都放入到这个队列里。使用callbacks而不是在nextTick中直接执行回调函数的原因是保证在同一个nexTick内执行完之前tick的所有异步任务，将多个异步任务压成一个同步任务，在下一个tick执行完毕。</p><p>flushCallbacks用于遍历callbacks并执行回调，并将pending设置为false，表示可以开始下一个tick。</p><p>macroTimerFunc会依次从setImmediate，MessageChannel，setTimeout中取，而microTimerFunc则先检测浏览器是否原生支持Promise，不支持则指向macroTimerFunc的实现。这两个函数中都会异步调用flushCallbacks，默认使用microTimerFunc。</p><p>看到这里，我们大概知道了nextTick做的事情了，可是之前的疑问还是没有得到答案啊，为什么修改了数据之后，需要在下一个tick里才会更新呢？好吧，接下来再去扒一扒源码。</p><h2 id=2-响应式原理><a href=#2-响应式原理 class=headerlink title="2. 响应式原理"></a>2. 响应式原理</h2><p>Vue使用Object.defineProperty把对象的属性转为getter/setter，这是响应式的核心，也是Vue不支持IE8以及更低版本浏览器的原因。下面是从官网盗的一张图。<br><img src=https://haitao.nos.netease.com/58ee9280-643d-45e7-86dd-2f9f2726ff13_1200_750.png alt=image></p><p>从上图可以知道，Data变化之后会Notify Watcher，而Watcher又会触发re-render。哦，原来是这样，但是还是不知道为什么修改Data之后一定要nextTick，Dom才会更新啊，继续低头扒代码…</p><h3 id=2-1-Observer><a href=#2-1-Observer class=headerlink title="2.1 Observer"></a>2.1 Observer</h3><p>Vue的Observer类的实现在<code>src/core/observer/index.js</code>，为了省点墨水这里就不填代码了，少侠请<a href=https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js target=_blank rel=external>移步</a>。</p><p><img src=https://haitao.nos.netease.com/c1bb3289-6c83-4279-b2eb-559600384d20_2118_1262.jpg alt=image></p><p>上面这张图是我根据代码画的（这么丑一看就知道肯定自己画的，凑合着看）。</p><p>Observer类的主要作用是给对象的属性添加getter和setter，收集依赖和派发更新。<br>defineReactive方法最为重要，它就实现了给对象属性添加getter和setter，收集依赖和派发更新。下面截取关键的源码（有删减）：<br><figure class="highlight plain"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div><div class=line>16</div><div class=line>17</div><div class=line>18</div><div class=line>19</div><div class=line>20</div><div class=line>21</div><div class=line>22</div><div class=line>23</div><div class=line>24</div><div class=line>25</div><div class=line>26</div><div class=line>27</div><div class=line>28</div><div class=line>29</div><div class=line>30</div><div class=line>31</div></pre></td><td class=code><pre><div class=line>let childOb = !shallow &amp;&amp; observe(val)</div><div class=line>Object.defineProperty(obj, key, &#123;</div><div class=line>    enumerable: true,</div><div class=line>    configurable: true,</div><div class=line>    get: function reactiveGetter () &#123;</div><div class=line>      const value = getter ? getter.call(obj) : val</div><div class=line>      if (Dep.target) &#123;</div><div class=line>        dep.depend()</div><div class=line>        if (childOb) &#123;</div><div class=line>          childOb.dep.depend()</div><div class=line>          if (Array.isArray(value)) &#123;</div><div class=line>            dependArray(value)</div><div class=line>          &#125;</div><div class=line>        &#125;</div><div class=line>      &#125;</div><div class=line>      return value</div><div class=line>    &#125;,</div><div class=line>    set: function reactiveSetter (newVal) &#123;</div><div class=line>      const value = getter ? getter.call(obj) : val</div><div class=line>      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</div><div class=line>        return</div><div class=line>      &#125;</div><div class=line>      if (setter) &#123;</div><div class=line>        setter.call(obj, newVal)</div><div class=line>      &#125; else &#123;</div><div class=line>        val = newVal</div><div class=line>      &#125;</div><div class=line>      childOb = !shallow &amp;&amp; observe(newVal)</div><div class=line>      dep.notify()</div><div class=line>    &#125;</div><div class=line>  &#125;)</div></pre></td></tr></table></figure></p><p>可以发现，defineReactive在getter和setter方法中分别实现了依赖收集和更新派发。</p><p>getter中执行完原getter之后，先判断Dep.target，在dep.depend()，并把val也都设置成响应式并收集了依赖。厉害啊！哎等等，Dep.target是什么？为什么要先判断这个呢？</p><p>setter中先判断val是否有改变，执行完原setter后（将newVal也设成响应式），dep.notify()。奥，仿佛明白了什么…</p><p>哎喂，Dep是什么？一开始都没说啊，从哪冒出来的？别急，我们接着看</p><h3 id=2-2-Dep><a href=#2-2-Dep class=headerlink title="2.2 Dep"></a>2.2 Dep</h3><p>Dep类的实现在<code>src/core/observer/dep.js</code>，照例，少侠请<a href=https://github.com/vuejs/vue/blob/dev/src/core/observer/dep.js target=_blank rel=external>移步</a>。</p><p>照例，上图</p><p><img src=https://haitao.nos.netease.com/a628c51f-1321-4228-8938-b5b2321d346f_800_1072.jpg alt=image></p><p>图上很明显（强行很明显），能找到上面Observer defineReactive方法用到的那几个方法，depend,notify,以及静态属性Dep.target，这下全明白了吧？并没有，Dep.target默认是null，不可能一直是null的呀，一直是null的话，那defineReactive的判断永远不会true啊。还有，subs是啥，notify里怎么还能update呢？哎，接着看吧emmmmm…</p><h3 id=2-3-Watcher><a href=#2-3-Watcher class=headerlink title="2.3 Watcher"></a>2.3 Watcher</h3><p>Watcher类的实现在<code>src/core/observer/watcher.js</code>，你懂的，请<a href=https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js target=_blank rel=external>移步</a>。</p><p><img src=https://haitao.nos.netease.com/95ab0e44-2624-46fb-8fd6-f0c0f0313ba8_2326_1596.jpg alt=image></p><p>Watcher有众多属性，其中deep,computed,user,sync,before对某些流程会有些影响的。对于普通的Watcher（非computed），constructor时会执行get方法。</p><p>get方法里我们一眼看到了pushTarget(this)，popTarget()，正是上面Dep中所看到的。讲道理，在Observer的defineReactive方法中，getter时判断Dep.target是否为空，不为空才会收集依赖，而此处成对出现的pushTarget和popTarget仿佛就是告诉我们，get方法里，pushTarget和popTarget中间肯定会执行Observer的getter。为了方便解释，贴一下get的代码（有删减）：<br><figure class="highlight plain"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div></pre></td><td class=code><pre><div class=line>pushTarget(this)</div><div class=line>let value</div><div class=line>const vm = this.vm</div><div class=line>try &#123;</div><div class=line>    value = this.getter.call(vm, vm)</div><div class=line>&#125; catch (e) &#123;</div><div class=line>    throw e</div><div class=line>&#125; finally &#123;</div><div class=line>    popTarget()</div><div class=line>    this.cleanupDeps()</div><div class=line>&#125;</div><div class=line>return value</div></pre></td></tr></table></figure></p><p>看过来看过去，最可疑的就是try的那一句 <code>this.getter.call(vm, vm)</code>。看下constructor中，原来this.getter是从expOrFn来的，是构造函数的第二个参数。这里先看到这里，继续看。<br>addDep，在Dep类的depend方法中，就是调用Dep.target.addDep方法，当Watcher get方法中pushTarget(this)，这个时候我们知道，此时Dep.target就是Watcher实例，addDep也就是这里addDep方法。<br>addDep将Dep的实例放入到Watcher实例的newDeps数组中，并将当前Watcher实例放入Dep实例的subs中（做了去重），实现依赖收集（好像有点绕）。</p><p>接下来重点来了，update方法，Dep的notify方法就是调用sub的update方法，也就是这里的update方法，定睛一看，对于普通watcher（非computed、非sync）来说，update调用的就是<code>queueWatcher(this)</code>；贴代码（删除注释）为证：<br><figure class="highlight plain"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div></pre></td><td class=code><pre><div class=line>update () &#123;</div><div class=line>  if (this.computed) &#123;</div><div class=line>    if (this.dep.subs.length === 0) &#123;</div><div class=line>      this.dirty = true</div><div class=line>    &#125; else &#123;</div><div class=line>      this.getAndInvoke(() =&gt; &#123;</div><div class=line>        this.dep.notify()</div><div class=line>      &#125;)</div><div class=line>    &#125;</div><div class=line>  &#125; else if (this.sync) &#123;</div><div class=line>    this.run()</div><div class=line>  &#125; else &#123;</div><div class=line>    queueWatcher(this)</div><div class=line>  &#125;</div><div class=line>&#125;</div></pre></td></tr></table></figure></p><p>那<code>queueWatcher</code>又是啥玩意呢，看到queue感到莫名的兴奋，觉得答案就在眼前！</p><h3 id=2-4-queueWatcher><a href=#2-4-queueWatcher class=headerlink title="2.4 queueWatcher"></a>2.4 queueWatcher</h3><figure class="highlight plain"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div><div class=line>16</div><div class=line>17</div><div class=line>18</div><div class=line>19</div><div class=line>20</div><div class=line>21</div><div class=line>22</div></pre></td><td class=code><pre><div class=line>export function queueWatcher (watcher: Watcher) &#123;</div><div class=line>  const id = watcher.id</div><div class=line>  if (has[id] == null) &#123;</div><div class=line>    has[id] = true</div><div class=line>    if (!flushing) &#123;</div><div class=line>      queue.push(watcher)</div><div class=line>    &#125; else &#123;</div><div class=line>      // if already flushing, splice the watcher based on its id</div><div class=line>      // if already past its id, it will be run next immediately.</div><div class=line>      let i = queue.length - 1</div><div class=line>      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</div><div class=line>        i--</div><div class=line>      &#125;</div><div class=line>      queue.splice(i + 1, 0, watcher)</div><div class=line>    &#125;</div><div class=line>    // queue the flush</div><div class=line>    if (!waiting) &#123;</div><div class=line>      waiting = true</div><div class=line>      nextTick(flushSchedulerQueue)</div><div class=line>    &#125;</div><div class=line>  &#125;</div><div class=line>&#125;</div></pre></td></tr></table></figure><p>嗯，按捺不住内心的欢喜，直接贴上了代码（连注释都来不及删了）。从下往上看，果然我看到了nextTick。接着看queueWatcher做了什么（源码请移步<a href=https://github.com/vuejs/vue/blob/dev/src/core/observer/scheduler.js target=_blank rel=external>scheduler</a>）</p><ul><li>看watcher是否已在队列，不在继续执行（在的话返回）</li><li>当前没有执行flush队列时，直接将watcher push到队列里，否则安装watch id的大小插入到队列里的相应位置（flush队列时会先排序在执行，这里插到对应位置防止顺序乱了）。</li><li>如果当前不在flush或者flush已结束，则开始新的flush，nextTick(flushSchedulerQueue)。</li><li>flushSchedulerQueue 里先按watcher id大小排序，执行watcher.run()，最后执行active 和 update的钩子函数。</li></ul><p>到这里我们好像知道了答案，修改Data之后，通知到watcher更新时，使用了nextTick去执行队列。</p><p>到此结束了吗？当然还没完啊，还记得那年大明湖畔的夏雨荷吗？啊呸，还记得Watcher get方法里的getter方法，到底是不是getter里执行到了Observer。哦，假装不记得的童鞋可以散了先。</p><h2 id=3-Vue-实例><a href=#3-Vue-实例 class=headerlink title="3. Vue 实例"></a>3. Vue 实例</h2><p>废话不多说，先上图</p><p><img src=https://haitao.nos.netease.com/d6b0b8fb-d4e2-4a90-a8d3-fb9f987b6008_2144_1510.svg alt=image></p><p><code>src/core/instance/index.js</code>是Vue实例的入口，Vue.prototype._init定义在<code>src/core/instance/init.js</code>，<code>_init</code>的在最后执行<code>vm.$mount()</code>,这里是将vue实例挂载到dom上的关键一步。</p><p>在<code>src/platforms/web/runtime/index.js</code>找到一处Vue.prototype.$mount定义（vue的编译入口有多个），这里的$mount实际调用的是<code>src/core/instance/lifecycle.js</code>中的mountComponent方法，这个方法里果然看到了两个重要的生命周期钩子函数的调用，根据Vue官网文档说明，Vue实例的挂载就应该是在两个钩子函数之间，上代码（关键代码）：<br><figure class="highlight plain"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div></pre></td><td class=code><pre><div class=line>updateComponent = () =&gt; &#123;</div><div class=line>    vm._update(vm._render(), hydrating)</div><div class=line>  &#125;</div><div class=line>new Watcher(vm, updateComponent, noop, &#123;</div><div class=line>  before () &#123;</div><div class=line>    if (vm._isMounted) &#123;</div><div class=line>      callHook(vm, &apos;beforeUpdate&apos;)</div><div class=line>    &#125;</div><div class=line>  &#125;</div><div class=line>&#125;, true /* isRenderWatcher */)</div></pre></td></tr></table></figure></p><p>很明显，mountComponent里调用new Watcher()生成一个renderWatcher，传入的getter正是updateComponent，updateComponent里调用<code>vm._update(vm._render())</code>，继续追查。</p><p>在<code>src/core/instance/render.js</code>中找到<code>Vue.prototype._render</code>的定义，原来<code>_render</code>调用的是<code>vm.$createElement</code>，而<code>vm.$createElement</code>定义在initRender中，使用的<code>src/core/vdom/create-element.js</code>。好了绕了一大圈终于找到了，从代码上看，createElement最终返回的是一个vnode，而在vnode的constructor里进行赋值就会触发Data的getter，getter里的Dep.target此时正是刚new的renderWatcher，依赖收集完成（在vue实例的iniMixin已经执行过initData，data早就是响应式的了）。</p><p>修改数据触发更新时，renderWatcher会被push进queue里，nextTick时renderWatcher调用run方法，run方法调用getAndInvoke方法，而getAndInvoke方法会调用get方法，get方法则会执行getter，也就是updateComponent，<code>vm._render()</code>返回一个新vnode，而<code>vm._update</code>会调用<code>vm.__patch__(preVnode, vnode)</code>，重新渲染。</p><p>好了，终于理（che）完了。</p><h2 id=参考：><a href=#参考： class=headerlink title=参考：></a>参考：</h2><ul><li><a href="https://ustbhuangyi.github.io/vue-analysis/" target=_blank rel=external>Vue.js技术揭秘</a></li><li><a href=http://lynnelv.github.io/js-event-loop-browser target=_blank rel=external>深入理解js事件循环机制（浏览器篇）</a></li></ul></div><div></div><div></div><footer class=post-footer><div class=post-tags><a href="/tags/javascript/" rel=tag># javascript</a> <a href="/tags/Vue/" rel=tag># Vue</a></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href="/2018/10/27/eggjs-from-enter-to-ready/" rel=next title=eggjs启动从回车到ready><i class="fa fa-chevron-left"></i> eggjs启动从回车到ready</a></div><span class=post-nav-divider></span><div class="post-nav-prev post-nav-item"><a href="/2018/01/12/kali-install-vncsever/" rel=prev title="kali2安装vnc server记录">kali2安装vnc server记录 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class=post-spread></div></div></div><div class=comments id=comments><div id=disqus_thread><noscript>Please enable JavaScript to view the <a href=//disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录</li><li class=sidebar-nav-overview data-target=site-overview>站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=https://haitao.nos.netease.com/6b466397-97dc-44d6-8614-893b6734b6f3.png alt=soonwang><p class=site-author-name itemprop=name>soonwang</p><p class="site-description motion-element" itemprop=description></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/archives><span class=site-state-item-count>8</span> <span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-tags"><a href=/tags><span class=site-state-item-count>8</span> <span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/wangsong3635 target=_blank title=GitHub><i class="fa fa-fw fa-github"></i> GitHub</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#0-浏览器事件循环机制><span class=nav-number>1.</span> <span class=nav-text>0 浏览器事件循环机制</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-单线程和异步><span class=nav-number>1.1.</span> <span class=nav-text>0.1 单线程和异步</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#0-2-tasks-macroTasks-和-microTasks><span class=nav-number>1.2.</span> <span class=nav-text>0.2 tasks (macroTasks) 和 microTasks</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#0-3-来做个题吧><span class=nav-number>1.3.</span> <span class=nav-text>0.3 来做个题吧</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#0-4-event-loop-处理顺序><span class=nav-number>1.4.</span> <span class=nav-text>0.4 event loop 处理顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#1-Vue-nextTick><span class=nav-number>2.</span> <span class=nav-text>1. Vue.$nextTick</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-nextTick-使用><span class=nav-number>2.1.</span> <span class=nav-text>1.1 nextTick 使用</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-nextTick-实现><span class=nav-number>2.2.</span> <span class=nav-text>1.2 nextTick 实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#2-响应式原理><span class=nav-number>3.</span> <span class=nav-text>2. 响应式原理</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-Observer><span class=nav-number>3.1.</span> <span class=nav-text>2.1 Observer</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-Dep><span class=nav-number>3.2.</span> <span class=nav-text>2.2 Dep</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-Watcher><span class=nav-number>3.3.</span> <span class=nav-text>2.3 Watcher</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-queueWatcher><span class=nav-number>3.4.</span> <span class=nav-text>2.4 queueWatcher</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#3-Vue-实例><span class=nav-number>4.</span> <span class=nav-text>3. Vue 实例</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#参考：><span class=nav-number>5.</span> <span class=nav-text>参考：</span></a></li></ol></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright>&copy; <span itemprop=copyrightYear>2019</span> <span class=with-love><i class="fa fa-heart"></i></span> <span class=author itemprop=copyrightHolder>soonwang</span></div><div class=powered-by>由 <a class=theme-link href=https://hexo.io>Hexo</a> 强力驱动</div><div class=theme-info>主题 - <a class=theme-link href=https://github.com/iissnan/hexo-theme-next>NexT.Pisces</a></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i></div></div><script type=text/javascript>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script><script type=text/javascript src=//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js></script><script type=text/javascript src=//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js></script><script type=text/javascript src=//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js></script><script type=text/javascript src=//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js></script><script type=text/javascript src=//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js></script><script type=text/javascript src=//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js></script><script type=text/javascript src="/js/src/utils.js?v=5.1.0"></script><script type=text/javascript src="/js/src/motion.js?v=5.1.0"></script><script type=text/javascript src="/js/src/affix.js?v=5.1.0"></script><script type=text/javascript src="/js/src/schemes/pisces.js?v=5.1.0"></script><script type=text/javascript src="/js/src/scrollspy.js?v=5.1.0"></script><script type=text/javascript src="/js/src/post-details.js?v=5.1.0"></script><script type=text/javascript src="/js/src/bootstrap.js?v=5.1.0"></script><script type=text/javascript>
      var disqus_shortname = 'http-soonwang-cn';
      var disqus_identifier = '2018/08/05/Vue.$nextTick/';

      var disqus_title = "Vue.$nextTick浅谈";


      function run_disqus_script(disqus_script) {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');

      
        var disqus_config = function () {
            this.page.url = disqus_url;
            this.page.identifier = disqus_identifier;
            this.page.title = disqus_title;
        };
        run_disqus_script('embed.js');
      

    </script></body></html>